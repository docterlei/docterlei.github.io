<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>箭头函数</title>
    <link href="/2021/02/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <url>/2021/02/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="1-没有-this-所以需要通过查找作用域链来确定-this-的值。这就意味着如果箭头函数被非箭头函数包含，this-绑定的就是最近一层非箭头函数的-this"><a href="#1-没有-this-所以需要通过查找作用域链来确定-this-的值。这就意味着如果箭头函数被非箭头函数包含，this-绑定的就是最近一层非箭头函数的-this" class="headerlink" title="1. 没有 this 所以需要通过查找作用域链来确定 this 的值。这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this"></a>1. 没有 this 所以需要通过查找作用域链来确定 this 的值。这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this</h3><h3 id="2-没有-arguments"><a href="#2-没有-arguments" class="headerlink" title="2. 没有 arguments"></a>2. 没有 arguments</h3><h3 id="3-不能通过-new-关键字调用"><a href="#3-不能通过-new-关键字调用" class="headerlink" title="3. 不能通过 new 关键字调用"></a>3. 不能通过 new 关键字调用</h3><h3 id="4-没有原型"><a href="#4-没有原型" class="headerlink" title="4. 没有原型"></a>4. 没有原型</h3><h3 id="5-没有-super"><a href="#5-没有-super" class="headerlink" title="5. 没有 super"></a>5. 没有 super</h3><blockquote><p>this 和 super 的区别：<br>  this 关键词指向函数所在的当前对象<br>  super 指向的是当前对象的原型对象</p></blockquote><h3 id="6-没有-new-target"><a href="#6-没有-new-target" class="headerlink" title="6. 没有 new.target"></a>6. 没有 new.target</h3><blockquote><p>因为不能使用 new 调用，所以也没有 new.target 值。<br>new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，<br>该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。<br>如果构造函数不是通过new命令或Reflect.construct()调用的，<br>new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>es6相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类数组对象与arguments</title>
    <link href="/2021/02/21/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8Earguments/"/>
    <url>/2021/02/21/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8Earguments/</url>
    
    <content type="html"><![CDATA[<h2 id="类数组对象与arguments"><a href="#类数组对象与arguments" class="headerlink" title="类数组对象与arguments"></a>类数组对象与arguments</h2><h3 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h3><blockquote><p>拥有一个 length 属性和若干个索引属性的对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;sex&#x27;</span>]<br><br><span class="hljs-keyword">var</span> arrLike = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;sex&#x27;</span>,<br>    length: <span class="hljs-string">&#x27;3&#x27;</span><br>&#125;<br>为什么交类数组对象？ 因为它的读写，获取长度，<span class="hljs-keyword">for</span> 遍历和数组都一样，区别是不能用数组的方法<br></code></pre></td></tr></table></figure><h3 id="类数组调用数组方法"><a href="#类数组调用数组方法" class="headerlink" title="类数组调用数组方法"></a>类数组调用数组方法</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">var arrLike = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;sex&#x27;</span>,<br>    length: <span class="hljs-string">&#x27;3&#x27;</span><br>&#125;<br><br>Array.prototype.join.call(arrLike, <span class="hljs-string">&#x27;&amp;&#x27;</span>) <span class="hljs-regexp">//</span> name&amp;age&amp;sex<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. slice类数组转数组<br>Array.prototype.slice.call(arrayLike); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>] <br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. splice类数组转数组<br>Array.prototype.splice.call(arrayLike, <span class="hljs-number">0</span>); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>] <br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span>. ES6 Array.from<br>Array.from(arrayLike); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>]<br><span class="hljs-regexp">//</span> <span class="hljs-number">4</span>. concat结合apply<br>Array.prototype.concat.apply([], arrayLike) <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>]<br><br>Array.prototype.map.call(arrayLike, <span class="hljs-keyword">function</span>(item)&#123;<br>    return item.toUpperCase();<br>&#125;); <br><span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;NAME&quot;</span>, <span class="hljs-string">&quot;AGE&quot;</span>, <span class="hljs-string">&quot;SEX&quot;</span>]<br><br>Arguments对象就是类素组对象，在客户端 JavaScript 中，一些 DOM 方法也返回类数组对象<br><br></code></pre></td></tr></table></figure><h3 id="Arguments对象"><a href="#Arguments对象" class="headerlink" title="Arguments对象"></a>Arguments对象</h3><blockquote><p>Arguments 对象只定义在函数体中，包括了函数的参数和其它属性，在函数体中，arguments 指代该函数的 Arguments 对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<br>&#125;<br><br>foo(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><p>打印结果如下：<br><img src="/images/Arguments.jpeg"></p><h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scilab">Arguments对象的<span class="hljs-built_in">length</span>属性，表示实参的长度，举个例子：<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(b, c, d)</span>&#123;</span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;实参的长度为：&quot;</span> + arguments.<span class="hljs-built_in">length</span>)<br>&#125;<br><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;形参的长度为：&quot;</span> + foo.<span class="hljs-built_in">length</span>)<br><br>foo(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 形参的长度为：3</span><br><span class="hljs-comment">// 实参的长度为：1</span><br><br></code></pre></td></tr></table></figure><h3 id="callee-属性-指向调用函数自身"><a href="#callee-属性-指向调用函数自身" class="headerlink" title="callee 属性 指向调用函数自身"></a>callee 属性 指向调用函数自身</h3><h3 id="Symbol-Symbol-iterator-它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署-Iterator-接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）"><a href="#Symbol-Symbol-iterator-它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署-Iterator-接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）" class="headerlink" title="Symbol(Symbol.iterator) 它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）"></a>Symbol(Symbol.iterator) 它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）</h3><h3 id="Argument和对应参数的绑定"><a href="#Argument和对应参数的绑定" class="headerlink" title="Argument和对应参数的绑定"></a>Argument和对应参数的绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name, age, sex, hobbit</span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(name, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// name name</span><br><br>    <span class="hljs-comment">// 改变形参</span><br>    name = <span class="hljs-string">&#x27;new name&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(name, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// new name new name</span><br><br>    <span class="hljs-comment">// 改变arguments</span><br>    <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;new age&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(age, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// new age new age</span><br><br>    <span class="hljs-comment">// 测试未传入的是否会绑定</span><br>    <span class="hljs-built_in">console</span>.log(sex); <span class="hljs-comment">// undefined</span><br><br>    sex = <span class="hljs-string">&#x27;new sex&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(sex, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>]); <span class="hljs-comment">// new sex undefined</span><br><br>    <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;new hobbit&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(hobbit, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>]); <span class="hljs-comment">// undefined new hobbit</span><br><br>&#125;<br><br>foo(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>)<br>传入的参数，实参和 <span class="hljs-built_in">arguments</span> 的值会共享，当没有传入时，实参与 <span class="hljs-built_in">arguments</span> 值不会共享<br><br>除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 <span class="hljs-built_in">arguments</span> 是不会共享的。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参数传递</title>
    <link href="/2021/02/07/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    <url>/2021/02/07/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="1-按值传递"><a href="#1-按值传递" class="headerlink" title="1.按值传递"></a>1.按值传递</h3><p>ECMAScript中所有函数的参数都是按值传递的 也就是说把函数外部的值复制给函数内部的参数，就是把值从一个变量复制到另一个变量 如下：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">v</span>) </span>&#123;<br>      v = <span class="hljs-number">2</span>;<br>      <span class="hljs-built_in">console</span>.log(v) <span class="hljs-comment">//2</span><br>  &#125;<br>  foo(a)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br><br>当传递 a 到函数 foo 中，相当于拷贝量一份 a 的值给了 v 函数中修改的都是 v 的值 而不会影响原来的 a 值<br><br></code></pre></td></tr></table></figure></p><h3 id="2-引用传递"><a href="#2-引用传递" class="headerlink" title="2. 引用传递"></a>2. 引用传递</h3><p>传递给函数的是对象的引用 函数内部对参数任何修改都会影响该对象的值 因为俩者引用的是同一个对象</p>   <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> obj = <span class="hljs-comment">&#123; a: 1&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(param)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    param.a = 2</span></span><br><span class="hljs-function"><span class="hljs-comment">    console.log(params.a) //2</span></span><br><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">(obj)</span></span><br><span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">(obj.a)</span> <span class="hljs-comment">// 2</span></span><br><span class="hljs-function">我们上面说 <span class="hljs-title">js</span> 是按值传递 现在这种情况 像是按引用传递了 其实这种是按共享传递</span><br></code></pre></td></tr></table></figure><h3 id="按共享传递"><a href="#按共享传递" class="headerlink" title="按共享传递"></a>按共享传递</h3><p>按共享传递 传递给函数的是传递对象的引用的副本  如下：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">param</span>) </span>&#123;<br>    param = <span class="hljs-number">2</span><br>    <span class="hljs-built_in">console</span>.log(param) <span class="hljs-comment">// 2</span><br>&#125;<br>foo(obj)<br><span class="hljs-built_in">console</span>.log(obj) <span class="hljs-comment">// &#123;a: 1&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>参数如果是基本类型是按值传递 如果是引用类型是按共享传递</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2021/02/07/%E9%97%AD%E5%8C%85/"/>
    <url>/2021/02/07/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="什么是闭包-（闭包-函数-函数能够访问的自由变量-本质就是外部自由变量（变量对象）保存其作用域链上）"><a href="#什么是闭包-（闭包-函数-函数能够访问的自由变量-本质就是外部自由变量（变量对象）保存其作用域链上）" class="headerlink" title="什么是闭包 ? （闭包 = 函数 + 函数能够访问的自由变量 本质就是外部自由变量（变量对象）保存其作用域链上）"></a>什么是闭包 ? （闭包 = 函数 + 函数能够访问的自由变量 本质就是外部自由变量（变量对象）保存其作用域链上）</h3><ul><li>即使创建它的上下文已经销毁，它依然存在</li><li>在代码中引用了自由变量（指在函数中使用，但既不是函数参数也不是函数局部变量的变量）</li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域链</title>
    <link href="/2021/02/02/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <url>/2021/02/02/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找<br>一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><h3 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h3><p>函数的作用域在函数定义的时候就决定了。<br>这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，<br>可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p><pre><code><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    var a = <span class="hljs-number">1</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>        var b = <span class="hljs-number">2</span><br>        console.<span class="hljs-built_in">log</span>(b) // <span class="hljs-string">[[Scopes]]</span>: Scopes[<span class="hljs-number">1</span>]<br>        // console.<span class="hljs-built_in">log</span>(a) 这里用到外部变量时 <span class="hljs-string">[[Scopes]]</span>: Scope[<span class="hljs-number">2</span>] 形成了闭包<br>    &#125;<br>    bar() <br>&#125;<br>foo()<br><br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量对象</title>
    <link href="/2021/02/02/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/02/02/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>变量对象是与执行上下文有关的数据域，存储了栈上下文中定义的变量和函数</p><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>全局上下文中的变量对象就是全局对象，全局对象是作用域链的头</p><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，<br>只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object，<br>而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>执行上下文代码会分成俩个阶段进行处理</p><ol><li><p>进入执行上下文</p><p> 当进入执行上下文时，这时候还没有执行代码，</p><p> 变量对象会包括：</p><ol><li>函数的所有形参 (如果是函数上下文)</li></ol><ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul><ol start="2"><li>函数声明</li></ol><ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul><ol start="3"><li>变量声明</li></ol><ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li><li><p>代码执行</p></li></ol><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span>第一题<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>    a = <span class="hljs-number">1</span>;<br>&#125;<br><br>foo(); <span class="hljs-comment">// ???</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br>bar(); <span class="hljs-comment">// ???</span><br>第一段会报错：Uncaught <span class="hljs-built_in">ReferenceError</span>: a is not defined。<br><br>第二段会打印：<span class="hljs-number">1</span>。<br><br>这是因为函数中的 <span class="hljs-string">&quot;a&quot;</span> 并没有通过 <span class="hljs-keyword">var</span> 关键字声明，所有不会被存放在 AO 中。<br><br>第一段执行 <span class="hljs-built_in">console</span> 的时候， AO 的值是：<br><br>AO = &#123;<br>    <span class="hljs-built_in">arguments</span>: &#123;<br>        length: <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。<br><br>当第二段执行 <span class="hljs-built_in">console</span> 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 <span class="hljs-number">1</span>。<br><br><span class="hljs-number">2.</span>第二题<br><br><span class="hljs-built_in">console</span>.log(foo);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br>会打印函数，而不是 <span class="hljs-literal">undefined</span> 。<br><br>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，<br>如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>执行上下文栈</title>
    <link href="/2021/02/01/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
    <url>/2021/02/01/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>js引擎并非一行一行的分析和执行程序，而是一段一段的分析执行，当执行一段代码时，会进行一个准备工作，比如变量提升、函数提升</p><h3 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h3><p>js有三种可执行代码（executable code） 全局代码、函数代码、eval代码，当遇到这三种时，就是做准备工作，此时会创建一个对应的<br>上下文（execution context）</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>js有全局上下文和函数上下文</p><p>每个执行上下文，都有三个重要的属性：变量对象（Variable object， VO），作用域链（Scope chain），this</p><h3 id="执行上下文栈-1"><a href="#执行上下文栈-1" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>js引擎创建了执行上下文栈（Execution context stack， ECS）来管理执行上下文 </p><p>当js开始执行代码的时候，最先遇到的就是全局代码，所以程序开始的时候就会向执行上下文栈压入一个全局执行上下文，只有程序结束的时候，<br>ECStack才会被清空，所以ECStack最低部永远有个全局执行上下文</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法作用域和动态作用域</title>
    <link href="/2021/01/29/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2021/01/29/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一套用来存储变量和访问变量的规则</p><h3 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h3><p>JavaScript采用的是静态作用域，函数的作用域在函数定义的时候就决定了，而与词法作用域相对的是动态作用域，函数的作用域是在函数调用时才决定的</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>    foo()<br>&#125;<br>bar() <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">/* 分析上面代码执行过程：因为js采用的是词法作用域， </span><br><span class="hljs-comment">执行foo函数，先从函数内部查找是否有局部变量a，如果</span><br><span class="hljs-comment">没有，就根据书写的位置，查找上一层的代码，也就是a等</span><br><span class="hljs-comment">于1，所以会打印1， 如果是动态作用域，会从调用函数的</span><br><span class="hljs-comment">作用域查找变量，也就是bar的内部，会打印2 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css</title>
    <link href="/2021/01/17/css/"/>
    <url>/2021/01/17/css/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>css</category>
      
      <category>js</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型到原型链</title>
    <link href="/2021/01/17/%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2021/01/17/%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="原型到原型链"><a href="#原型到原型链" class="headerlink" title="原型到原型链"></a>原型到原型链</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每个函数都有一个prototype属性，这个属性指向了一个对象，这个对象正是用该构造函数创建的实例的原型</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// prototype 是函数才有的属性</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;<br>Person.prototype.alias = <span class="hljs-string">&#x27;monster&#x27;</span><br><span class="hljs-keyword">const</span> michael = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-keyword">const</span> andrew = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-built_in">console</span>.log(michael.alias) <span class="hljs-comment">// monster</span><br><span class="hljs-built_in">console</span>.log(andrew.alias) <span class="hljs-comment">// monster</span><br></code></pre></td></tr></table></figure></code></pre><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p>每一个JavaScritp对象(null除外)都有一个__proto__属性，这个属性会指向该对象的原型</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;<br><span class="hljs-keyword">const</span> michael = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-built_in">console</span>.log(michael.__proto__ === Person.prototype) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>原型： 每一个JavaScript对象(null除外)在创建的时候会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性</code></pre><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>每个原型都有一个 constructor 属性指向关联的构造函数</p><pre><code><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment"></span></span><br><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><br><span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">(Person === Person.prototype.<span class="hljs-keyword">constructor</span>)</span>;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></code></pre><h3 id="如下图-对象之间形成了一条原型链"><a href="#如下图-对象之间形成了一条原型链" class="headerlink" title="如下图 对象之间形成了一条原型链"></a>如下图 对象之间形成了一条原型链</h3><p><img src="/images/prototypeChain.png"></p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
