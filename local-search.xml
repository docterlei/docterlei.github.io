<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>我的快捷键技巧</title>
    <link href="/2021/07/05/%E6%88%91%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/07/05/%E6%88%91%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<ol><li><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><a href="https://www.bilibili.com/video/BV1db411a7gq">参考文章</a></h3></li></ol>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
      <category>快捷键</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其它</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode快捷键</title>
    <link href="/2021/07/05/Vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/07/05/Vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<ol><li>command + shift + p 全局命令面板</li><li>command + p 快速打开最近打开的文件</li><li>command + shift + n 打开新的编辑器窗口</li><li>command + shift + w 关闭编辑器（自定义的快捷键）</li><li>option + ⬆️/⬇️ 移动行上下</li><li>shift + option + ⬆️/⬇️ 在当前行上下复制当前行</li><li>command + shift + enter 在当前行上插入新的一行</li><li>command + k command + 0 折叠所有区域代码</li><li>command + k command + 0 展开所有折叠的子区域代码</li></ol><h3 id="如何打开设置文件-先打开命令面板-然后输入settings-选择Open-settings-JSON"><a href="#如何打开设置文件-先打开命令面板-然后输入settings-选择Open-settings-JSON" class="headerlink" title="如何打开设置文件 先打开命令面板 然后输入settings 选择Open settings(JSON)"></a>如何打开设置文件 先打开命令面板 然后输入settings 选择Open settings(JSON)</h3>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
      <category>快捷键</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其它</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>void与undefined的指向</title>
    <link href="/2021/06/17/void%E4%B8%8Eundefined%E7%9A%84%E6%8C%87%E5%90%91/"/>
    <url>/2021/06/17/void%E4%B8%8Eundefined%E7%9A%84%E6%8C%87%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h3 id="void-0-与-undefined的区别"><a href="#void-0-与-undefined的区别" class="headerlink" title="void 0 与 undefined的区别"></a>void 0 与 undefined的区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a  = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] !== (<span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] : <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> a; <br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="上面代码-void-0-返回-undefined，-为什么不直接-arguments-0-undefined-？"><a href="#上面代码-void-0-返回-undefined，-为什么不直接-arguments-0-undefined-？" class="headerlink" title="上面代码 void 0 返回 undefined， 为什么不直接 arguments[0] !== undefined ？"></a>上面代码 void 0 返回 undefined， 为什么不直接 arguments[0] !== undefined ？</h4><ol><li>undefined可以被重写，undefined 在 ES5 中已经是全局对象的一个只读（read-only）属性它    不能被重写。但是在局部作用域中，还是可以被重写的<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-number">10</span>;<br><br>      <br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span>);<span class="hljs-comment">// 10 -- chrome</span><br>    &#125;)();<br> <br><span class="hljs-comment">// 在浏览器控制台下 不会报错 但是不生效</span><br>  <span class="hljs-literal">undefined</span> = <span class="hljs-number">10</span>;<br>  alert(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// undefined -- chrome</span><br><br></code></pre></td></tr></table></figure></li><li>void 运算符能对给定的表达式进行求值，然后返回 undefined。也就是说，void 后面你随便跟上一个表达式，返回的都是 undefined，如 void (2), void (‘hello’)。并且void是不能被重写的。但为什么是void 0 呢，void 0 是表达式中最短的。<strong>用 void 0 代替 undefined 能节省字节</strong>。不少 JavaScript 压缩工具在压缩过程中，正是将 undefined 用 void 0 代替掉了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this指向</title>
    <link href="/2021/06/17/this%E6%8C%87%E5%90%91/"/>
    <url>/2021/06/17/this%E6%8C%87%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h2><h4 id="1-函数外面的-this，即全局作用域的-this-指向-window，-严格模式下，函数里面的-this-指向-undefined-函数外面的-this-还是指向"><a href="#1-函数外面的-this，即全局作用域的-this-指向-window，-严格模式下，函数里面的-this-指向-undefined-函数外面的-this-还是指向" class="headerlink" title="1. 函数外面的 this，即全局作用域的 this 指向 window， 严格模式下，函数里面的 this 指向 undefined, 函数外面的 this 还是指向"></a>1. 函数外面的 this，即全局作用域的 this 指向 window， 严格模式下，函数里面的 this 指向 undefined, 函数外面的 this 还是指向</h4><h4 id="2-函数内部的-this-总是指向直接调用者，如果没有直接调用者，隐含调用者是-window"><a href="#2-函数内部的-this-总是指向直接调用者，如果没有直接调用者，隐含调用者是-window" class="headerlink" title="2. 函数内部的 this 总是指向直接调用者，如果没有直接调用者，隐含调用者是 window"></a>2. 函数内部的 this 总是指向直接调用者，如果没有直接调用者，隐含调用者是 window</h4><h4 id="3-实用-new-调用一个函数，函数里面的-this-指向实例对象"><a href="#3-实用-new-调用一个函数，函数里面的-this-指向实例对象" class="headerlink" title="3. 实用 new 调用一个函数，函数里面的 this 指向实例对象"></a>3. 实用 new 调用一个函数，函数里面的 this 指向实例对象</h4><h4 id="4-DOM事件回调里面，this指向绑定事件的对象"><a href="#4-DOM事件回调里面，this指向绑定事件的对象" class="headerlink" title="4. DOM事件回调里面，this指向绑定事件的对象"></a>4. DOM事件回调里面，this指向绑定事件的对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === e.currentTarget);   <span class="hljs-comment">// 总是true</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === e.target);          <span class="hljs-comment">// 如果target等于currentTarget,这个就为true</span><br>&#125;<br><br><span class="hljs-keyword">const</span> ele = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>);<br><br>ele.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, func);<br><br>currentTarget指的是绑定事件的DOM对象，target指的是触发事件的对象。DOM事件回调里面<span class="hljs-built_in">this</span>总是指向currentTarget，如果触发事件的对象刚好是绑定事件的对象，即target === currentTarget，<span class="hljs-built_in">this</span>也会顺便指向target。如果回调是箭头函数，<span class="hljs-built_in">this</span>是箭头函数申明时作用域的<span class="hljs-built_in">this</span>。<br><br></code></pre></td></tr></table></figure><h4 id="5-箭头函数本身没有-this，箭头函数在被声明时确定-this，会把当前作用域的-this-作为自己的-this"><a href="#5-箭头函数本身没有-this，箭头函数在被声明时确定-this，会把当前作用域的-this-作为自己的-this" class="headerlink" title="5. 箭头函数本身没有 this，箭头函数在被声明时确定 this，会把当前作用域的 this 作为自己的 this"></a>5. 箭头函数本身没有 this，箭头函数在被声明时确定 this，会把当前作用域的 this 作为自己的 this</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;monster&quot;</span>;<br><br>    <span class="hljs-keyword">var</span> obj = &#123;<br>      name: <span class="hljs-string">&quot;andrew&quot;</span>,<br>      func: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> anotherFunc = obj.func;<br><br>    obj.func();      <span class="hljs-comment">// monster</span><br>    anotherFunc();   <span class="hljs-comment">// monster</span><br>    上述代码里面的obj.func()输出也是“monster”，是因为obj在创建时申明了箭头函数，这时候箭头函数会去寻找当前作用域，因为obj是一个对象，并不是作用域，所以这里的作用域是<span class="hljs-built_in">window</span>，<span class="hljs-built_in">this</span>也就是<span class="hljs-built_in">window</span>了。<br><br><span class="hljs-number">2.</span>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;monster&quot;</span>;<br><br>    <span class="hljs-keyword">var</span> obj = &#123;<br>      name: <span class="hljs-string">&quot;andrew&quot;</span>,<br>      func: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          getName: <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> anotherFunc = obj.func().getName;<br><br>    obj.func().getName();      <span class="hljs-comment">// andrew</span><br>    anotherFunc();   <span class="hljs-comment">// andrew</span><br>    <br>    obj.func().getName()输出andrew，这里箭头函数是在obj.func()的返回值里申明的，<br>    这时他的<span class="hljs-built_in">this</span>其实就是func()的<span class="hljs-built_in">this</span>，因为他是被obj调用的，所以<span class="hljs-built_in">this</span>指向obj。<br><br>    那为什么anotherFunc()输出也是“小小飞”呢？这是因为anotherFunc()输出的<span class="hljs-built_in">this</span>，<br>    其实在anotherFunc赋值时就确定了：<br><br>    1<span class="hljs-keyword">var</span> anotherFunc = obj.func().getName;其实是先执行了obj.func()<br>    <span class="hljs-number">2</span>执行obj.func()的时候getName箭头函数被申明<br>    <span class="hljs-number">3</span>这时候箭头函数的<span class="hljs-built_in">this</span>应该是当前作用域的<span class="hljs-built_in">this</span>，也就是func()里面的<span class="hljs-built_in">this</span><br>    4func()因为是被obj调用，所以<span class="hljs-built_in">this</span>指向obj<br>    <span class="hljs-number">5</span>调用anotherFunc时，其实<span class="hljs-built_in">this</span>早就确定了，也就是obj，最终输出的是obj.myName。<br>    <br><span class="hljs-number">3.</span>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;monster&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;andrew&quot;</span>;<br><br>      <span class="hljs-keyword">const</span> getName = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>      &#125;<br><br>      getName();<br>    &#125;<br><br>    <span class="hljs-keyword">new</span> func(); <span class="hljs-comment">// 输出啥？</span><br>    这里输出的是“andrew”，原理还是一样的，箭头函数在申明时<span class="hljs-built_in">this</span>确定为当前作用域的<span class="hljs-built_in">this</span>，在这里就是func的作用域，跟func的<span class="hljs-built_in">this</span>一样指向<span class="hljs-keyword">new</span>出来的实例。如果不用<span class="hljs-keyword">new</span>，而是直接调用，这里的<span class="hljs-built_in">this</span>就指向<span class="hljs-built_in">window</span>。<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优秀文章</title>
    <link href="/2021/03/31/%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0/"/>
    <url>/2021/03/31/%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="优秀文章"><a href="#优秀文章" class="headerlink" title="优秀文章"></a>优秀文章</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾调用优化</a></li><li><a href="https://juejin.cn/post/6974184935804534815">我在工作中是如何使用 git 的</a></li><li><a href="https://juejin.cn/post/6844903890278694919#heading-5">彻底弄懂前端路由</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>get和post</title>
    <link href="/2021/03/29/get%E5%92%8Cpost/"/>
    <url>/2021/03/29/get%E5%92%8Cpost/</url>
    
    <content type="html"><![CDATA[<h2 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h2><h3 id="常见概念误区"><a href="#常见概念误区" class="headerlink" title="常见概念误区"></a>常见概念误区</h3><p>1 HTTP 是一个应用层的协议，而不是传输层的协议<br>2 Http Get方法提交的数据大小长度并没有限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的服务器和浏览器的对它的限制 POST按照协议来说是没有限制的，但是一般服务器都有限制，比如java使用的tomcat默认限制是2M,可以配置server.xml的一个参数maxPostSize=“0”取消限制</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>1 语义上 get 用于”读取资源“ post 用于新建/改写资源</p><p>2 get具有幂等性</p><p>3 get 请求中的URL可以被手动输入</p><p>4 缓存的问题。GET 请求默认是会被缓存的 ，这样就会减轻服务器端的压力。但是post请求是不会被缓存的 就是GET的URL会被放在浏览器历史和WEB 服务器日志里面 所以如果你把关键数据放在GET里面，被人偷窥了浏览器，或者WEB服务器被入侵日志被人倒去了，基本泄露可能性100%。而POST来说，日志没有记录，只要数据库服务器不被入侵，基本还是安全的。当然如果被抓了包，这一切都没有什么卵用，所以，HTTPS该用还是得用</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个git终端配置多个Git仓库和账户</title>
    <link href="/2021/03/29/%E4%B8%80%E4%B8%AAgit%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAGit%E4%BB%93%E5%BA%93%E5%92%8C%E8%B4%A6%E6%88%B7/"/>
    <url>/2021/03/29/%E4%B8%80%E4%B8%AAgit%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAGit%E4%BB%93%E5%BA%93%E5%92%8C%E8%B4%A6%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="1-生成公钥和私钥"><a href="#1-生成公钥和私钥" class="headerlink" title="1 生成公钥和私钥"></a>1 生成公钥和私钥</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">1</span> 创建目录及config文件<br>mkdir -p  ~<span class="hljs-regexp">/.ssh/</span><br>touch ~<span class="hljs-regexp">/.ssh/</span>config<br><br><span class="hljs-number">2</span> 进入到 .ssh目录下，利用账户邮箱生成密钥<br>cd ~/.ssh<br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;邮箱名&quot;</span><br><br><span class="hljs-number">3</span> 执行上述命令后，会有如下提示<br>Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key pair.<br>Enter <span class="hljs-keyword">file</span> in which to save the key (<span class="hljs-regexp">/Users/</span>bigdata<span class="hljs-regexp">/.ssh/i</span>d_rsa):<br>冒号后是给生成的密钥起个名字，每个账户要区分开来，以github为例，命名为id_rsa_github<br><br><span class="hljs-number">4</span> 接下来的提示都直接进行回车，直到秘钥生成<br><span class="hljs-number">5</span> 如有其它账户 重新执行上述操作<br></code></pre></td></tr></table></figure><h3 id="2-将私钥添加到本地"><a href="#2-将私钥添加到本地" class="headerlink" title="2 将私钥添加到本地"></a>2 将私钥添加到本地</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-add -K  ~<span class="hljs-regexp">/.ssh/i</span>d_rsa<br>ssh-add -K  ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github<br></code></pre></td></tr></table></figure><h3 id="3-对本地私钥进行配置，生产config文件"><a href="#3-对本地私钥进行配置，生产config文件" class="headerlink" title="3 对本地私钥进行配置，生产config文件"></a>3 对本地私钥进行配置，生产config文件</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">#网站的别名</span><br>Host gitlab.xxx.com<br><span class="hljs-meta"># 托管网站的域名</span><br>HostName gitlab.xxx.com<br><span class="hljs-meta">#指定优先使用哪种方式验证, 支持密码和秘钥验证方式</span><br>PreferredAuthentications publickey<br><span class="hljs-meta"># 托管网站上的用户名, 最好写账户邮箱, 否则容易设置失败</span><br>User gitlab@<span class="hljs-number">126.</span>com<br><span class="hljs-meta"># 使用的密钥文件</span><br>IdentityFile ~/.ssh/id_rsa<br><br><span class="hljs-meta">#网站的别名</span><br>Host github.xxx.com<br><span class="hljs-meta"># 托管网站的域名</span><br>HostName github.xxx.com<br><span class="hljs-meta">#指定优先使用哪种方式验证, 支持密码和秘钥验证方式</span><br>PreferredAuthentications publickey<br><span class="hljs-meta"># 托管网站上的用户名, 最好写账户邮箱, 否则容易设置失败</span><br>User gitlab@<span class="hljs-number">126.</span>com<br><span class="hljs-meta"># 使用的密钥文件</span><br>IdentityFile ~/.ssh/id_rsa_github<br></code></pre></td></tr></table></figure><h3 id="4-将公钥添加到托管网站"><a href="#4-将公钥添加到托管网站" class="headerlink" title="4 将公钥添加到托管网站"></a>4 将公钥添加到托管网站</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">将<span class="hljs-selector-class">.ssh</span>目录下的<span class="hljs-selector-tag">id_rsa</span><span class="hljs-selector-class">.pub</span>和<span class="hljs-selector-tag">id_rsa_github</span><span class="hljs-selector-class">.pub</span>中的内容复制，分别设置到<span class="hljs-selector-tag">GitLab</span>和<span class="hljs-selector-tag">GitHub</span>的<span class="hljs-selector-tag">SSH</span> <span class="hljs-selector-tag">keys</span>中<br><br>复制命令：<span class="hljs-selector-tag">pbcopy</span> &lt; ~/<span class="hljs-selector-class">.ssh</span>/<span class="hljs-selector-tag">id_rsa_github</span><span class="hljs-selector-class">.pub</span><br></code></pre></td></tr></table></figure><h3 id="5-配置邮箱和用户名"><a href="#5-配置邮箱和用户名" class="headerlink" title="5 配置邮箱和用户名"></a>5 配置邮箱和用户名</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog">但是因为存在双/多账户，需要通过Git配置不同账户的用户和邮箱，这里采取一个用全局用户名和邮箱配置，而另一个针对每个clone到本地的项目进行单独的用户名和邮箱配置，避免冲突<br><br><span class="hljs-comment">// 配置全局的用户名和邮箱 将GitLab设置为全局</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;gitlab&quot;</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;gitlab@126.com&quot;</span><br><br><span class="hljs-comment">// 为GitHub上的每个repository/项目单独设置用户名和邮箱 注意：下述命令要到每个本地GitHub项目目录下执行</span><br>git <span class="hljs-keyword">config</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;github&quot;</span><br>git <span class="hljs-keyword">config</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;github@126.com&quot;</span><br></code></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/131007696">一个git终端配置多个Git仓库和账户</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其它</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环境配置</title>
    <link href="/2021/03/29/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/03/29/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><a href="https://github.com/521xueweihan/GitHub520">Github520</a></p><p><a href="https://zhuanlan.zhihu.com/p/111014448">Homebrew安装</a></p><p><a href="https://www.cnblogs.com/xishuai/p/mac-iterm2.html">Iterm2 + Oh-My-Zsh</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">上面连接中配置高亮有问题 换成下面的命令<br>执行如下命令<br><span class="hljs-number">1</span> git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zsh-users/</span>zsh-syntax-highlighting.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span><span class="hljs-regexp">/plugins/</span>zsh-syntax-highlighting<br><span class="hljs-number">2</span> 通过在~/.zshrc中加入插件的名字 plugins=( [plugins...] zsh-syntax-highlighting)<br><span class="hljs-number">3</span> 执行 source ~/.zshrc<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/caiqiiqi/article/details/52139288">使用zsh插件<code>zsh-syntax-highlighting</code>高亮你的zsh可用命令</a></p><p><a href="https://www.npmjs.com/package/n">node版本管理器</a></p><p><a href="https://www.npmjs.com/package/nrm">配置npm源</a></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其它</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>insertSort</title>
    <link href="/2021/03/26/insertSort/"/>
    <url>/2021/03/26/insertSort/</url>
    
    <content type="html"><![CDATA[<h2 id="插入排序-稳定性-稳定-时间复杂度-O-n-2"><a href="#插入排序-稳定性-稳定-时间复杂度-O-n-2" class="headerlink" title="插入排序 稳定性(稳定) 时间复杂度 O(n^2)"></a>插入排序 稳定性(稳定) 时间复杂度 O(n^2)</h2><blockquote><p>将左侧看成一个有序数组 每次将一个数字插入该有序序列 插入时 从有序序列的最右侧比较 若比较的数较大 后移一位</p></blockquote><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs inform7">var arr = <span class="hljs-comment">[9, 4, 3, 1, 5, 7, 8, 2]</span><br><br>for(let i = 1; i &lt; arr.length; i++) &#123;<br>    let target = i<br>    for(var j = i - 1; j &gt;= 0; j--) &#123;<br>        if(arr<span class="hljs-comment">[target]</span> &lt; arr<span class="hljs-comment">[j]</span>)&#123;<br>            <span class="hljs-comment">[arr<span class="hljs-comment">[j]</span>, arr<span class="hljs-comment">[target]</span>]</span> = <span class="hljs-comment">[arr<span class="hljs-comment">[target]</span>, arr<span class="hljs-comment">[j]</span>]</span><br>                target = j<br>        &#125; else &#123;<br>            break;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>selectionSort</title>
    <link href="/2021/03/26/selectionSort/"/>
    <url>/2021/03/26/selectionSort/</url>
    
    <content type="html"><![CDATA[<h2 id="选择排序-稳定性-稳定-时间复杂度-O-n-2"><a href="#选择排序-稳定性-稳定-时间复杂度-O-n-2" class="headerlink" title="选择排序 稳定性(稳定) 时间复杂度 O(n^2)"></a>选择排序 稳定性(稳定) 时间复杂度 O(n^2)</h2><blockquote><p>循环数组 每轮比较找出最小值的索引 然后默认索引对比 如果不相等 就交换</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">var</span> minIndex = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[minIndex] &gt; arr[j]) &#123;<br>            minIndex = j<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">var</span> temp = arr[i]<br>    arr[i] = arr[minIndex]<br>    arr[minIndex] = temp<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bubbleSort</title>
    <link href="/2021/03/24/bubbleSort/"/>
    <url>/2021/03/24/bubbleSort/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序-稳定性-稳定-时间复杂度-O-n-2"><a href="#冒泡排序-稳定性-稳定-时间复杂度-O-n-2" class="headerlink" title="冒泡排序 稳定性(稳定) 时间复杂度 O(n^2)"></a>冒泡排序 稳定性(稳定) 时间复杂度 O(n^2)</h2><blockquote><p>循环数组 比较当前元素和下一个元素 如果当前元素比下一个元素大， 向上冒泡 这样循环一次之后最后一个数就是数组最大大数，下一次循环继续上面大操作，不循环已经排好序的数</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">var arr = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]<br><br>for(var i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; arr.length - 1; i++) &#123;</span><br>    for(var <span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; arr.length - i; j++) &#123;</span><br>        let temp;<br>        if(arr[<span class="hljs-keyword">j] </span>&gt; arr[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>]) &#123;<br>            temp = arr[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>]<br>            arr[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>] = arr[<span class="hljs-keyword">j]</span><br><span class="hljs-keyword"> </span>           arr[<span class="hljs-keyword">j] </span>= temp<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="优化外层循环"><a href="#优化外层循环" class="headerlink" title="优化外层循环"></a>优化外层循环</h3><blockquote><p>利用外层循环 当内层循环中没有发生冒泡 说明排序已经完成 直接在本来循环后终止循环</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> isBubble = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - i; j++) &#123;<br>        <span class="hljs-keyword">let</span> temp;<br>        <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            temp = arr[j + <span class="hljs-number">1</span>]<br>            arr[j + <span class="hljs-number">1</span>] = arr[j]<br>            arr[j] = temp<br>            isBubble = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(isBubble) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="优化内层循环"><a href="#优化内层循环" class="headerlink" title="优化内层循环"></a>优化内层循环</h3><blockquote><p>利用内层循环 记录下每次内层循环最后一次发生冒泡的索引 后面没有发生冒泡 表示后面数排序已经完成 下次循环就不循环后面的了</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]<br><span class="hljs-keyword">let</span> lastExchangeIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最后一次交换的位置</span><br><span class="hljs-keyword">let</span> sortBorder = arr.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 无序数列的边界 每次只需要比到这里</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> isBubble = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; sortBorder; j++) &#123;<br>        <span class="hljs-keyword">let</span> temp;<br>        <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            temp = arr[j + <span class="hljs-number">1</span>]<br>            arr[j + <span class="hljs-number">1</span>] = arr[j]<br>            arr[j] = temp<br>            lastExchangeIndex = j<br>            isBubble = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    sortBorder = lastExchangeIndex<br>    <span class="hljs-keyword">if</span>(isBubble) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>utils</title>
    <link href="/2021/03/16/utils/"/>
    <url>/2021/03/16/utils/</url>
    
    <content type="html"><![CDATA[<h3 id="1-获取一个随机布尔值"><a href="#1-获取一个随机布尔值" class="headerlink" title="1. 获取一个随机布尔值"></a>1. 获取一个随机布尔值</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const randomBoolean = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Math</span>.random() &gt;= <span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure><h3 id="2-检查日期是否为工作日"><a href="#2-检查日期是否为工作日" class="headerlink" title="2. 检查日期是否为工作日"></a>2. 检查日期是否为工作日</h3><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">get</span><span class="hljs-built_in">Day</span>()返回一星期中的某一天（<span class="hljs-number">0</span><span class="hljs-number">-6</span>）<br><span class="hljs-keyword">get</span><span class="hljs-built_in">Date</span>()返回一个月中的某一天（<span class="hljs-number">1</span><span class="hljs-number">-31</span>）<br><span class="hljs-keyword">const</span> isWeekday = (date) =&gt; date.<span class="hljs-keyword">get</span><span class="hljs-built_in">Day</span>() % <span class="hljs-number">6</span> !== <span class="hljs-number">0</span> <br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">is</span><span class="hljs-built_in">Weekday</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()))<br></code></pre></td></tr></table></figure><h3 id="3-检查当前-Tab-页是否在前台"><a href="#3-检查当前-Tab-页是否在前台" class="headerlink" title="3. 检查当前 Tab 页是否在前台"></a>3. 检查当前 Tab 页是否在前台</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const isBroserTabInView = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">document</span>.hidden<br><span class="hljs-built_in">console</span>.log(isBroserTabInView())<br></code></pre></td></tr></table></figure><h3 id="4-检查数字是否为偶数"><a href="#4-检查数字是否为偶数" class="headerlink" title="4. 检查数字是否为偶数"></a>4. 检查数字是否为偶数</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const isEven = <span class="hljs-function"><span class="hljs-params">(num)</span> =&gt;</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br><span class="hljs-built_in">console</span>.log(isEven(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h3 id="5-滚动到页面顶部"><a href="#5-滚动到页面顶部" class="headerlink" title="5. 滚动到页面顶部"></a>5. 滚动到页面顶部</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const goTop = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">window</span>.scrollTo(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.log(goTop())<br></code></pre></td></tr></table></figure><h3 id="6-获取所有参数平均值"><a href="#6-获取所有参数平均值" class="headerlink" title="6. 获取所有参数平均值"></a>6. 获取所有参数平均值</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const getAverage = <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> args.reduce(<span class="hljs-function"><span class="hljs-params">(acc, cur)</span> =&gt;</span> acc + cur) / args.length<br><span class="hljs-built_in">console</span>.log(getAverage(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br></code></pre></td></tr></table></figure><h3 id="7-获取页面有多少种类型的标签"><a href="#7-获取页面有多少种类型的标签" class="headerlink" title="7. 获取页面有多少种类型的标签"></a>7. 获取页面有多少种类型的标签</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...<span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelectorAll</span>(<span class="hljs-string">&#x27;*&#x27;</span>)].map(ele=&gt; ele.tagName)).size<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AMD-CMD-Commonjs-UMD-ESModule</title>
    <link href="/2021/03/16/AMD-CMD-Commonjs-UMD-ESModule/"/>
    <url>/2021/03/16/AMD-CMD-Commonjs-UMD-ESModule/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么要出现模块化？"><a href="#为什么要出现模块化？" class="headerlink" title="为什么要出现模块化？"></a>为什么要出现模块化？</h3><blockquote><p>早起我们引入javascript文件都是通过script标签引入js文件代码，当然，这样写简单需求没有问题，当我们项目越来越大，引入的文件越来越多时，就会出现如下问题：</p></blockquote><ol><li>js文件作用域都是顶层，这会造成变量污染</li><li>js文件变多，不好维护</li><li>js文件依赖问题，稍微不注意顺序引错，代码全报错</li></ol><h3 id="AMD-是-RequireJS-在推广过程中对模块定义的规范化产出"><a href="#AMD-是-RequireJS-在推广过程中对模块定义的规范化产出" class="headerlink" title="AMD 是 RequireJS 在推广过程中对模块定义的规范化产出"></a>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">([<span class="hljs-string">&#x27;./a&#x27;</span>, <span class="hljs-string">&#x27;./b&#x27;</span>], function(a, b)</span></span> &#123; <span class="hljs-comment">// 依赖必须一开始就写好</span><br>    <span class="hljs-selector-tag">a</span>.doSomething()<br>    <span class="hljs-comment">// 此处略去 100 行</span><br>    <span class="hljs-selector-tag">b</span>.doSomething()<br>    ...<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="CMD-是-SeaJS-在推广过程中对模块定义的规范化产出"><a href="#CMD-是-SeaJS-在推广过程中对模块定义的规范化产出" class="headerlink" title="CMD 是 SeaJS 在推广过程中对模块定义的规范化产出"></a>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">([<span class="hljs-string">&#x27;./a&#x27;</span>, <span class="hljs-string">&#x27;./b&#x27;</span>], function(a, b)</span></span> &#123; <span class="hljs-comment">// 依赖开始就写好</span><br>    <span class="hljs-selector-tag">a</span>.doSomething()<br>    <span class="hljs-comment">// 此处略去 100 行</span><br>    <span class="hljs-selector-tag">b</span>.doSomething()<br>    ...<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="ADM-和-CMD-区别"><a href="#ADM-和-CMD-区别" class="headerlink" title="ADM 和 CMD 区别"></a>ADM 和 CMD 区别</h3><blockquote><ol><li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行                                                                   2. CMD 推崇依赖就近，AMD 推崇依赖前置</li></ol></blockquote><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><blockquote><p>CommonJS 主要运行于服务器端，该规范指出，一个单独的文件就是一个模块。 Node.js为主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。require 命令用于输入其他模块提供的功能，module.exports命令用于规范模块的对外接口，输出的是一个值的拷贝，输出之后就不能改变了，会缓存起来</p></blockquote><blockquote><p>CommonJS 采用同步加载模块，而加载的文件资源大多数在本地服务器，所以执行速度或时间没问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模块 a.js</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;qiufeng&#x27;</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    name,<br>    github: <span class="hljs-string">&#x27;https://github.com/hua1995116&#x27;</span><br>&#125;<br><span class="hljs-comment">// 模块 b.js</span><br><span class="hljs-comment">// 引用核心模块或者第三方包模块，不需要写完整路径</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-comment">// 引用自定义模块可以省略.js</span><br><span class="hljs-keyword">const</span> &#123; name, github &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(name, github, path.basename(github));<br><span class="hljs-comment">// 输出 qiufeng https://github.com/hua1995116 hua1995116</span><br></code></pre></td></tr></table></figure><h3 id="UMD-UMD-Universal-Module-Definition-通用模块定义-模式，该模式主要用来解决CommonJS模式和AMD模式代码不能通用的问题，并同时还支持老式的全局变量规范"><a href="#UMD-UMD-Universal-Module-Definition-通用模块定义-模式，该模式主要用来解决CommonJS模式和AMD模式代码不能通用的问题，并同时还支持老式的全局变量规范" class="headerlink" title="UMD UMD(Universal Module Definition - 通用模块定义)模式，该模式主要用来解决CommonJS模式和AMD模式代码不能通用的问题，并同时还支持老式的全局变量规范"></a>UMD UMD(Universal Module Definition - 通用模块定义)模式，该模式主要用来解决CommonJS模式和AMD模式代码不能通用的问题，并同时还支持老式的全局变量规范</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bundle.js</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">global</span>, factory</span>) </span>&#123;<br>    <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-built_in">module</span>.exports = factory() :<br>    <span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; define.amd ? define(factory) :<br>    (<span class="hljs-built_in">global</span> = <span class="hljs-built_in">global</span> || self, <span class="hljs-built_in">global</span>.myBundle = factory());<br>&#125;(<span class="hljs-built_in">this</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-string">&#x27;use strict&#x27;</span>;<br><br>    <span class="hljs-keyword">var</span> main = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> main;<br><br>&#125;)));<br><span class="hljs-comment">// index.html</span><br>&lt;script src=<span class="hljs-string">&quot;bundle.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  <span class="hljs-built_in">console</span>.log(myBundle());<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="ES-modules"><a href="#ES-modules" class="headerlink" title="ES modules"></a>ES modules</h3><blockquote><p>import只能声明在该文件的最顶部，不能动态加载语句，Es Module`语句运行在代码编译时</p></blockquote><h3 id="CommonJs和Es-Module的区别"><a href="#CommonJs和Es-Module的区别" class="headerlink" title="CommonJs和Es Module的区别"></a>CommonJs和Es Module的区别</h3><h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><pre><code>1. CommonJs可以动态加载语句，代码发生在运行时2. CommonJs混合导出，不能修改exports的引用值，因为它指向的是module.exports，最终导出的也是module.exports3. CommonJs导出值是拷贝，可以修改导出的值，这在代码出错时，不好排查引起变量污染</code></pre><h4 id="Es-Module"><a href="#Es-Module" class="headerlink" title="Es Module"></a>Es Module</h4><pre><code>1. Es Module是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时2. Es Module混合导出，单个导出，默认导出，完全互不影响3. Es Module导出是引用值之前都存在映射关系，并且值都是可读的，不能修改</code></pre>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP</title>
    <link href="/2021/03/08/TCP/"/>
    <url>/2021/03/08/TCP/</url>
    
    <content type="html"><![CDATA[<h3 id="建立-TCP-连接-，而-HTTPS-在-TCP-三次握手之后，还需进行-SSL-TSL-的握手过程，才可进入加密报文传输"><a href="#建立-TCP-连接-，而-HTTPS-在-TCP-三次握手之后，还需进行-SSL-TSL-的握手过程，才可进入加密报文传输" class="headerlink" title="建立 TCP 连接 ，而 HTTPS 在 TCP 三次握手之后，还需进行 SSL / TSL 的握手过程，才可进入加密报文传输"></a>建立 TCP 连接 ，而 HTTPS 在 TCP 三次握手之后，还需进行 SSL / TSL 的握手过程，才可进入加密报文传输</h3><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><pre><code>1. 第一次握手： 客户端会随机初始化序号 （clent_isn），将此序号置于 TCP 首部的 序号 字段中， 同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文 发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态2. 服务端收到客户端的 SYN 报文后， 首先服务端也初始化自己的序号（server_isn），将此序号填入 TCP 首部的序号字段中， 其次把 TCP 首部的 确认应答号 字段填入 client_isn + 1,接着把 SYN 和 ACK 标志位置为 1， 最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态3. 客户端收到服务端报文后，还要向服务端回应一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1， 其次 确认应答号 字段填入 server_isn + 1,最后把报文发送给服务端，这次报文可以携带数据，之后客户端处于 ESTABLISHED，服务端收到客户端的应答报文后，也进入 ESTABLISHED</code></pre><h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h3><pre><code>在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题**。</code></pre><h3 id="确认应答号"><a href="#确认应答号" class="headerlink" title="确认应答号"></a>确认应答号</h3><pre><code>指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决不丢包的问题**。</code></pre><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><pre><code>1. 客户端打算关闭连接， 此时会发送一个 TCP 首部 FIN 标志位为 1 的报文， 即 FIN 报文， 之后客户端进入 FIN_WAIT_1 状态。2. 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态3. 客户端收到服务端的 ACK 应答报文后，进入 FIN_WAIT_2 状态4. 等待服务端处理完数据后， 也向客户端发送 FIN 报文， 之后服务端进入 LAST_ACK 状态5. 客户端收到服务端的 FIN 报文后， 回一个 ACK 应答报文， 之后进入 TIME_WAIT状态6. 服务器收到了 ACK 应答报文后，就进入了 CLOSE 状态， 至此服务端已经完成连接的关闭7. 客户端在经过 2MSL（60秒） 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭因为每个方向都需要一个 FIN 和 一个 ACK，因此通常被称为 四次挥手， 有一点需要注意： **主动关闭连接的 才有 TIME_WAIT状态**</code></pre><h4 id="为什么挥手需要四次"><a href="#为什么挥手需要四次" class="headerlink" title="为什么挥手需要四次"></a>为什么挥手需要四次</h4><pre><code>1. 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还是能接收数据2. 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文， 而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送， 从而比三次握手导致多了一次</code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://mp.weixin.qq.com/s/bHZ2_hgNQTKFZpWMCfUH9A">实战！我用“大白鲨”让你看见 TCP</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS域名解析</title>
    <link href="/2021/03/01/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/03/01/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><h3 id="DNS-域名的层级关系树一个树状结构"><a href="#DNS-域名的层级关系树一个树状结构" class="headerlink" title="DNS 域名的层级关系树一个树状结构"></a>DNS 域名的层级关系树一个树状结构</h3><ul><li>根 DNS 服务器</li><li>顶级域 DNS 服务器（.com,.cn…）</li><li>权威 DNS 服务器（163.com）</li></ul><p><img src="/images/dns.jpeg" alt="DNS树状结构"></p><h3 id="DNS-域名查找过程"><a href="#DNS-域名查找过程" class="headerlink" title="DNS 域名查找过程"></a>DNS 域名查找过程</h3><blockquote><p>根域的 DNS 服务器信息保存在互联网所有的 DNS 服务器中</p></blockquote><ol><li><p>在客户端输入 URL 后， 会有一个查找过程， 这个过程中任何一步找到了都会结束查找流程</p><ol><li>浏览器缓存</li><li>本地 hosts 文件</li><li>本地 DNS 服务器缓存查找</li></ol></li><li><p>如果上一步没找到 会进行如下查找：</p><ol><li>本地 DNS 服务器会去问它的根域名服务器，“老大，能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？“<br> 根域名服务器不直接用于域名解析，但它能指明一条道路</li><li>根 DNS 服务器发现后置是 .com 后，会把 .com 顶级域名服务器 IP 地址返回回来</li><li>本地 DNS 收到顶级域名服务器 IP 后， 发起请求问 “老二， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP地址吗”</li><li>顶级域名服务器会返回权威服务器 IP 地址</li><li>本地 DNS 收到权威 IP 后，发起请求问 “老三， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP地址吗”</li><li>权威 DNS 服务器查询后将对应的 IP 地址告诉本地 DNS</li><li>本地 DNS 再将 IP 地址返回客户端，然后客户端和目标建立连接</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么尽量不要用index作为key</title>
    <link href="/2021/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E7%94%A8index%E4%BD%9C%E4%B8%BAkey/"/>
    <url>/2021/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E7%94%A8index%E4%BD%9C%E4%B8%BAkey/</url>
    
    <content type="html"><![CDATA[<h3 id="1-因为这样做会导致性能变差-这个策略在元素不进行重新排序时比较合适，但一旦有顺序修改，diff-就会变得慢-因为组件的子元素会重新渲染"><a href="#1-因为这样做会导致性能变差-这个策略在元素不进行重新排序时比较合适，但一旦有顺序修改，diff-就会变得慢-因为组件的子元素会重新渲染" class="headerlink" title="1.因为这样做会导致性能变差(这个策略在元素不进行重新排序时比较合适，但一旦有顺序修改，diff 就会变得慢, 因为组件的子元素会重新渲染)"></a>1.因为这样做会导致性能变差(这个策略在元素不进行重新排序时比较合适，但一旦有顺序修改，diff 就会变得慢, 因为组件的子元素会重新渲染)</h3><ol><li>index为key：<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">变化前数组的值是[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]，<span class="hljs-built_in">key</span>就是对应的下标：<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>,   <br>变化后数组的值是[<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]，<span class="hljs-built_in">key</span>对应的下标也是：<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span><br><br>那么<span class="hljs-built_in">diff</span>算法在变化前的数组找到<span class="hljs-built_in">key</span> =<span class="hljs-number">0</span>的值是<span class="hljs-number">1</span>，在变化后数组里找到的<span class="hljs-built_in">key</span>=<span class="hljs-number">0</span>的值是<br>因为子元素不一样就重新删除并更新<br></code></pre></td></tr></table></figure></li><li>唯一key<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">变化前数组的值是[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]，<span class="hljs-built_in">key</span>就是对应的下标：id0，id1，id2，id3<br>变化后数组的值是[<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]，<span class="hljs-built_in">key</span>对应的下标也是：id3，id2，id1，id0<br><br>那么<span class="hljs-built_in">diff</span>算法在变化前的数组找到<span class="hljs-built_in">key</span> =id0的值是<span class="hljs-number">1</span>，在变化后数组里找到的<span class="hljs-built_in">key</span>=id0的值也是<span class="hljs-number">1</span>，<br>因为子元素相同，就不删除并更新，只做移动操作，这就提升了性能<br></code></pre></td></tr></table></figure><h3 id="2-还可能引起组件状态的问题-可查看下面的例子"><a href="#2-还可能引起组件状态的问题-可查看下面的例子" class="headerlink" title="2.还可能引起组件状态的问题,可查看下面的例子"></a>2.还可能引起组件状态的问题,可查看下面的例子</h3><a href="https://codesandbox.io/s/amazing-ramanujan-ohkb0?file=/src/App.js">使用索引作为key的负面影响</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>react相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从输入url到获得页面到过程</title>
    <link href="/2021/02/23/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E5%88%B0%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/02/23/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E5%88%B0%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="从输入url到获得页面到过程"><a href="#从输入url到获得页面到过程" class="headerlink" title="从输入url到获得页面到过程"></a>从输入url到获得页面到过程</h2><h3 id="1-构建请求"><a href="#1-构建请求" class="headerlink" title="1. 构建请求"></a>1. 构建请求</h3><blockquote><p>使用浏览器进行请求后，浏览器会先判断地址栏中输入的是 query（关键字）还是URL，</p><blockquote><ol><li>如果是URL，则把URL转发给网络进程，网络进程会构建请求行信息，构建好之后，浏览器就准备发起网络请求</li><li>如果是关键字，浏览器会自动生成一个带有我们搜索关键字的 URL，然后向默认的搜索引擎发起连接请求，后面和输入 URL 一样</li></ol></blockquote></blockquote><h3 id="2-查找强缓存"><a href="#2-查找强缓存" class="headerlink" title="2. 查找强缓存"></a>2. 查找强缓存</h3><blockquote><p>浏览器在发起真正的网络请求前，会先检查浏览器的强缓存，如果命中，直接返回对应资源文件的副本，否则进入下一步</p></blockquote><h3 id="3-DNS解析"><a href="#3-DNS解析" class="headerlink" title="3. DNS解析"></a>3. DNS解析</h3><blockquote><p>发起真正的网络请求前，首先需要进行 DNS 解析，目的就是找到 URL 对应的服务器的 IP 地址</p></blockquote><h3 id="4-建立-TCP-连接-如果是-HTTP-，三次握手之后便可进行-HTTP-的报文传输，而-HTTPS-在-TCP-三次握手之后，还需要进行-SSL-TSL-的握手过程，然后才可进行加密报文传输"><a href="#4-建立-TCP-连接-如果是-HTTP-，三次握手之后便可进行-HTTP-的报文传输，而-HTTPS-在-TCP-三次握手之后，还需要进行-SSL-TSL-的握手过程，然后才可进行加密报文传输" class="headerlink" title="4. 建立 TCP 连接 如果是 HTTP ，三次握手之后便可进行 HTTP 的报文传输，而 HTTPS 在 TCP 三次握手之后，还需要进行 SSL / TSL 的握手过程，然后才可进行加密报文传输"></a>4. 建立 TCP 连接 如果是 HTTP ，三次握手之后便可进行 HTTP 的报文传输，而 HTTPS 在 TCP 三次握手之后，还需要进行 SSL / TSL 的握手过程，然后才可进行加密报文传输</h3><blockquote><p>建立了 TCP 连接， 浏览器就可以和服务器进行通信了，HTTP 中的数据就是在这个通信过程中传输的</p></blockquote><h3 id="5-发送请求"><a href="#5-发送请求" class="headerlink" title="5. 发送请求"></a>5. 发送请求</h3><h3 id="6-查找协商缓存"><a href="#6-查找协商缓存" class="headerlink" title="6. 查找协商缓存"></a>6. 查找协商缓存</h3><h3 id="7-断开TCP连接"><a href="#7-断开TCP连接" class="headerlink" title="7. 断开TCP连接"></a>7. 断开TCP连接</h3><h3 id="8-浏览器渲染"><a href="#8-浏览器渲染" class="headerlink" title="8. 浏览器渲染"></a>8. 浏览器渲染</h3><h3 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h3><p><img src="/images/getPageProcess.png" alt="从输入url到获得页面到过程"></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xss攻击</title>
    <link href="/2021/02/23/xss%E6%94%BB%E5%87%BB/"/>
    <url>/2021/02/23/xss%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><blockquote><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全</p></blockquote><h3 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h3><ol><li><p>存储型</p><ul><li>概念：存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，它不需要用户手动触发</li><li>攻击步骤：<ol><li>击者将恶意代码提交到目标网站的数据库中</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ol></li><li>攻击方法：常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</li></ul></li><li><p>反射型</p><ul><li>概念：反射型XSS也被称为非持久性XSS。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行</li><li>攻击步骤：<ol><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ol></li><li>攻击方法：常见于通过 URL 传递参数的功能，如网站搜索、跳转等</li></ul></li><li><p>DOM型</p><ul><li>概念：DOM 型 XSS 攻击中，<strong>取出和执行</strong>恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于<strong>服务端</strong>的安全漏洞</li><li>攻击步骤：<ol><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的 URL</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ol></li><li>攻击方法：DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</li></ul></li></ol><h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><ol><li>对输入(和URL参数)进行过滤，对输出进行编码。</li><li>内容安全策略（内容安全策略）<blockquote><p>CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置</p></blockquote></li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://tech.meituan.com/2018/09/27/fe-security.html">如何防止XSS攻击?</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html">Content Security Policy 入门教程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络模型</title>
    <link href="/2021/02/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/02/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="OSI-和-TCP-IP模型对比"><a href="#OSI-和-TCP-IP模型对比" class="headerlink" title="OSI 和 TCP/IP模型对比"></a>OSI 和 TCP/IP模型对比</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60be38880ed346258a8fd4c59538d39f~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="TCP-IP-模型对应的相关协议及对应数据单位"><a href="#TCP-IP-模型对应的相关协议及对应数据单位" class="headerlink" title="TCP/IP 模型对应的相关协议及对应数据单位"></a>TCP/IP 模型对应的相关协议及对应数据单位</h3><ul><li>应用层：<ul><li>HTTP, FTP</li><li>报文(message)</li></ul></li><li>传输层：<ul><li>TCP, UDP</li><li>数据段(segment)</li></ul></li><li>网络层：<ul><li>IP, ICMP </li><li>分组或者数据包(packets)</li></ul></li><li>数据链路层：<ul><li>ARP, RARP</li><li>帧(frame) 物理层传输的单位是比特(bit)</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http缓存</title>
    <link href="/2021/02/22/http%E7%BC%93%E5%AD%98/"/>
    <url>/2021/02/22/http%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP缓存分为强制缓存和协商缓存"><a href="#HTTP缓存分为强制缓存和协商缓存" class="headerlink" title="HTTP缓存分为强制缓存和协商缓存"></a>HTTP缓存分为强制缓存和协商缓存</h2><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>有俩个字段来表明失效规则（Expires / Cache-control）</p><ul><li>Expires的值表示服务端返回的到期时间，即下一次请求，如果时间小于服务器到期时间 直接使用缓存数据 <ol><li>Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，一般用来向下兼容</li><li>到期时间是由服务端生成的，如果修改了客户端的时间，就会导致缓存命中的误差</li></ol></li><li>Cache-control 有如下几个值：<ol><li>private 客户端可以缓存</li><li>public 客户端和代理服务器都要缓存</li><li>max-age 如果值为 800， 意思就是缓存的内容将在 800 秒后失效</li><li>no-cache 需使用协商缓存来验证缓存数据</li><li>no-store 所有内容都不会缓存，<strong>强制缓存和协商缓存都不会触发</strong></li></ol></li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>对比强制缓存，协商缓存会<strong>发送请求</strong>到服务器 </p><ul><li>Last-Modified / If-Modified-Since<ul><li>Last-Modified 服务器在相应请求时，告诉浏览器资源的最后修改时间</li><li>If-Modified-Since 再次请求服务器时，浏览器会将上次请求到的Last-Modified的值作为 If-Modified-Since值发送给服务器，服务器接受后，发现有If-Modified-Since字段，则与被请求资源的最后修改时间进行对比，如果资源的最后修改时间大于If-Modified-Since的值，说明资源被改动过，则响应整体的资源内容。如果不大于，说明资源无修改 则相应 <strong>HTTP 304</strong>，告诉浏览器继续使用缓存的数据</li></ul></li><li>Etag / If-None-Match(优先级高于Last-Modified / If-Modified-Since)<ul><li>Etag 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）</li><li>If-None-Match 再次请求服务器时，浏览器会将上次请求到的Etag的值作为 If-None-Match值发送给服务器，服务器接受后，发现有If-None-Match字段，则与被请求资源的最后修改时间进行对比，不同，说明资源被改动过，则响应整体的资源内容。相同，说明资源无修改 则相应 <strong>HTTP 304</strong>，告诉浏览器继续使用缓存的数据</li></ul></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>箭头函数</title>
    <link href="/2021/02/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <url>/2021/02/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="1-没有-this-所以需要通过查找作用域链来确定-this-的值。这就意味着如果箭头函数被非箭头函数包含，this-绑定的就是最近一层非箭头函数的-this"><a href="#1-没有-this-所以需要通过查找作用域链来确定-this-的值。这就意味着如果箭头函数被非箭头函数包含，this-绑定的就是最近一层非箭头函数的-this" class="headerlink" title="1. 没有 this 所以需要通过查找作用域链来确定 this 的值。这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this"></a>1. 没有 this 所以需要通过查找作用域链来确定 this 的值。这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this</h3><h3 id="2-没有-arguments"><a href="#2-没有-arguments" class="headerlink" title="2. 没有 arguments"></a>2. 没有 arguments</h3><h3 id="3-不能通过-new-关键字调用"><a href="#3-不能通过-new-关键字调用" class="headerlink" title="3. 不能通过 new 关键字调用"></a>3. 不能通过 new 关键字调用</h3><h3 id="4-没有原型"><a href="#4-没有原型" class="headerlink" title="4. 没有原型"></a>4. 没有原型</h3><h3 id="5-没有-super"><a href="#5-没有-super" class="headerlink" title="5. 没有 super"></a>5. 没有 super</h3><blockquote><p>this 和 super 的区别：<br>  this 关键词指向函数所在的当前对象<br>  super <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super">关键字用于访问和调用一个对象的副对象上的函数</a><br>  继承的子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象</p></blockquote><h3 id="6-没有-new-target"><a href="#6-没有-new-target" class="headerlink" title="6. 没有 new.target"></a>6. 没有 new.target</h3><blockquote><p>因为不能使用 new 调用，所以也没有 new.target 值。<br>new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，<br>该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。<br>如果构造函数不是通过new命令或Reflect.construct()调用的，<br>new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>es6相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类数组对象与arguments</title>
    <link href="/2021/02/21/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8Earguments/"/>
    <url>/2021/02/21/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8Earguments/</url>
    
    <content type="html"><![CDATA[<h2 id="类数组对象与arguments"><a href="#类数组对象与arguments" class="headerlink" title="类数组对象与arguments"></a>类数组对象与arguments</h2><h3 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h3><blockquote><p>拥有一个 length 属性和若干个索引属性的对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;sex&#x27;</span>]<br><br><span class="hljs-keyword">var</span> arrLike = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;sex&#x27;</span>,<br>    length: <span class="hljs-string">&#x27;3&#x27;</span><br>&#125;<br>为什么交类数组对象？ 因为它的读写，获取长度，<span class="hljs-keyword">for</span> 遍历和数组都一样，区别是不能用数组的方法<br></code></pre></td></tr></table></figure><h3 id="类数组调用数组方法"><a href="#类数组调用数组方法" class="headerlink" title="类数组调用数组方法"></a>类数组调用数组方法</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">var arrLike = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;sex&#x27;</span>,<br>    length: <span class="hljs-string">&#x27;3&#x27;</span><br>&#125;<br><br>Array.prototype.join.call(arrLike, <span class="hljs-string">&#x27;&amp;&#x27;</span>) <span class="hljs-regexp">//</span> name&amp;age&amp;sex<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. slice类数组转数组<br>Array.prototype.slice.call(arrayLike); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>] <br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. splice类数组转数组<br>Array.prototype.splice.call(arrayLike, <span class="hljs-number">0</span>); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>] <br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span>. ES6 Array.from<br>Array.from(arrayLike); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>]<br><span class="hljs-regexp">//</span> <span class="hljs-number">4</span>. concat结合apply<br>Array.prototype.concat.apply([], arrayLike) <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>]<br><br>Array.prototype.map.call(arrayLike, <span class="hljs-keyword">function</span>(item)&#123;<br>    return item.toUpperCase();<br>&#125;); <br><span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;NAME&quot;</span>, <span class="hljs-string">&quot;AGE&quot;</span>, <span class="hljs-string">&quot;SEX&quot;</span>]<br><br>Arguments对象就是类素组对象，在客户端 JavaScript 中，一些 DOM 方法也返回类数组对象<br><br></code></pre></td></tr></table></figure><h3 id="Arguments对象"><a href="#Arguments对象" class="headerlink" title="Arguments对象"></a>Arguments对象</h3><blockquote><p>Arguments 对象只定义在函数体中，包括了函数的参数和其它属性，在函数体中，arguments 指代该函数的 Arguments 对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<br>&#125;<br><br>foo(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><p>打印结果如下：<br><img src="/images/Arguments.jpeg"></p><h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scilab">Arguments对象的<span class="hljs-built_in">length</span>属性，表示实参的长度，举个例子：<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(b, c, d)</span>&#123;</span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;实参的长度为：&quot;</span> + arguments.<span class="hljs-built_in">length</span>)<br>&#125;<br><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;形参的长度为：&quot;</span> + foo.<span class="hljs-built_in">length</span>)<br><br>foo(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 形参的长度为：3</span><br><span class="hljs-comment">// 实参的长度为：1</span><br><br></code></pre></td></tr></table></figure><h3 id="callee-属性-指向调用函数自身"><a href="#callee-属性-指向调用函数自身" class="headerlink" title="callee 属性 指向调用函数自身"></a>callee 属性 指向调用函数自身</h3><h3 id="Symbol-Symbol-iterator-它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署-Iterator-接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）"><a href="#Symbol-Symbol-iterator-它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署-Iterator-接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）" class="headerlink" title="Symbol(Symbol.iterator) 它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）"></a>Symbol(Symbol.iterator) 它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）</h3><h3 id="Argument和对应参数的绑定"><a href="#Argument和对应参数的绑定" class="headerlink" title="Argument和对应参数的绑定"></a>Argument和对应参数的绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name, age, sex, hobbit</span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(name, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// name name</span><br><br>    <span class="hljs-comment">// 改变形参</span><br>    name = <span class="hljs-string">&#x27;new name&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(name, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// new name new name</span><br><br>    <span class="hljs-comment">// 改变arguments</span><br>    <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;new age&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(age, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// new age new age</span><br><br>    <span class="hljs-comment">// 测试未传入的是否会绑定</span><br>    <span class="hljs-built_in">console</span>.log(sex); <span class="hljs-comment">// undefined</span><br><br>    sex = <span class="hljs-string">&#x27;new sex&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(sex, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>]); <span class="hljs-comment">// new sex undefined</span><br><br>    <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;new hobbit&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(hobbit, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>]); <span class="hljs-comment">// undefined new hobbit</span><br><br>&#125;<br><br>foo(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>)<br>传入的参数，实参和 <span class="hljs-built_in">arguments</span> 的值会共享，当没有传入时，实参与 <span class="hljs-built_in">arguments</span> 值不会共享<br><br>除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 <span class="hljs-built_in">arguments</span> 是不会共享的。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参数传递</title>
    <link href="/2021/02/07/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    <url>/2021/02/07/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="1-按值传递"><a href="#1-按值传递" class="headerlink" title="1.按值传递"></a>1.按值传递</h3><p>ECMAScript中所有函数的参数都是按值传递的 也就是说把函数外部的值复制给函数内部的参数，就是把值从一个变量复制到另一个变量 如下：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">v</span>) </span>&#123;<br>      v = <span class="hljs-number">2</span>;<br>      <span class="hljs-built_in">console</span>.log(v) <span class="hljs-comment">//2</span><br>  &#125;<br>  foo(a)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br><br>当传递 a 到函数 foo 中，相当于拷贝量一份 a 的值给了 v 函数中修改的都是 v 的值 而不会影响原来的 a 值<br><br></code></pre></td></tr></table></figure></p><h3 id="2-引用传递"><a href="#2-引用传递" class="headerlink" title="2. 引用传递"></a>2. 引用传递</h3><p>传递给函数的是对象的引用 函数内部对参数任何修改都会影响该对象的值 因为俩者引用的是同一个对象</p>   <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> obj = <span class="hljs-comment">&#123; a: 1&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(param)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    param.a = 2</span></span><br><span class="hljs-function"><span class="hljs-comment">    console.log(params.a) //2</span></span><br><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">(obj)</span></span><br><span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">(obj.a)</span> <span class="hljs-comment">// 2</span></span><br><span class="hljs-function">我们上面说 <span class="hljs-title">js</span> 是按值传递 现在这种情况 像是按引用传递了 其实这种是按共享传递</span><br></code></pre></td></tr></table></figure><h3 id="按共享传递"><a href="#按共享传递" class="headerlink" title="按共享传递"></a>按共享传递</h3><p>按共享传递 传递给函数的是传递对象的引用的副本  如下：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">param</span>) </span>&#123;<br>    param = <span class="hljs-number">2</span><br>    <span class="hljs-built_in">console</span>.log(param) <span class="hljs-comment">// 2</span><br>&#125;<br>foo(obj)<br><span class="hljs-built_in">console</span>.log(obj) <span class="hljs-comment">// &#123;a: 1&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>参数如果是基本类型是按值传递 如果是引用类型是按共享传递</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Variables</title>
    <link href="/2021/02/07/Variables/"/>
    <url>/2021/02/07/Variables/</url>
    
    <content type="html"><![CDATA[<h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><h3 id="1-使用有意义且可读的变量名"><a href="#1-使用有意义且可读的变量名" class="headerlink" title="1. 使用有意义且可读的变量名"></a>1. 使用有意义且可读的变量名</h3><h3 id="Bad："><a href="#Bad：" class="headerlink" title="Bad："></a>Bad：</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> yyyymmdstr = moment().<span class="hljs-keyword">format</span>(<span class="hljs-string">&quot;YYYY/MM/DD&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="Good："><a href="#Good：" class="headerlink" title="Good："></a>Good：</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> currentDate = moment().<span class="hljs-keyword">format</span>(<span class="hljs-string">&quot;YYYY/MM/DD&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2-对同一个变量类型使用同一词语"><a href="#2-对同一个变量类型使用同一词语" class="headerlink" title="2. 对同一个变量类型使用同一词语"></a>2. 对同一个变量类型使用同一词语</h3><h3 id="Bad：-1"><a href="#Bad：-1" class="headerlink" title="Bad："></a>Bad：</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">getUserInfo()<span class="hljs-comment">;</span><br>getClientData()<span class="hljs-comment">;</span><br>getCustomerRecord()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="Good：-1"><a href="#Good：-1" class="headerlink" title="Good："></a>Good：</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">getUser()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="3-使用可搜索的名字"><a href="#3-使用可搜索的名字" class="headerlink" title="3. 使用可搜索的名字"></a>3. 使用可搜索的名字</h3><p>我们读的代码会比写的要多.我们写的代码可读可搜索很重要.不对理解程序有意义的变量命名，将会伤害我们的读者. 使你的变量名字可搜索. 工具像<a href="https://github.com/danielstjules/buddy.js">buddy.js</a> 和<br><a href="https://github.com/eslint/eslint/blob/660e0918933e6e7fede26bc675a0763a6b357c94/docs/rules/no-magic-numbers.md">ESLint</a>可以帮助验证没有命名的变量</p><h3 id="Bad：-2"><a href="#Bad：-2" class="headerlink" title="Bad："></a>Bad：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// What the heck is 86400000 for?</span><br>set<span class="hljs-constructor">Timeout(<span class="hljs-params">blastOff</span>, 86400000)</span>;<br></code></pre></td></tr></table></figure><h3 id="Good：-2"><a href="#Good：-2" class="headerlink" title="Good："></a>Good：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// Declare them as capitalized named constants.</span><br><span class="hljs-keyword">const</span> MILLISECONDS_PER_DAY = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">//86400000;</span><br><br><span class="hljs-built_in">setTimeout</span>(blastOff, MILLISECONDS_PER_DAY);<br><br></code></pre></td></tr></table></figure><h3 id="4-使用说明变量"><a href="#4-使用说明变量" class="headerlink" title="4. 使用说明变量"></a>4. 使用说明变量</h3><h3 id="Bad：-3"><a href="#Bad：-3" class="headerlink" title="Bad："></a>Bad：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> address = <span class="hljs-string">&quot;One Infinite Loop, Cupertino 95014&quot;</span>;<br><span class="hljs-keyword">const</span> cityZipCodeRegex = <span class="hljs-regexp">/^[^,\\]+[,\\\s]+(.+?)\s*(\d&#123;5&#125;)?$/</span>;<br>saveCityZipCode(<br>  address.match(cityZipCodeRegex)[<span class="hljs-number">1</span>],<br>  address.match(cityZipCodeRegex)[<span class="hljs-number">2</span>]<br>);<br></code></pre></td></tr></table></figure><h3 id="Good：-3"><a href="#Good：-3" class="headerlink" title="Good："></a>Good：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> address = <span class="hljs-string">&quot;One Infinite Loop, Cupertino 95014&quot;</span>;<br><span class="hljs-keyword">const</span> cityZipCodeRegex = <span class="hljs-regexp">/^[^,\\]+[,\\\s]+(.+?)\s*(\d&#123;5&#125;)?$/</span>;<br><span class="hljs-keyword">const</span> [_, city, zipCode] = address.match(cityZipCodeRegex) || [];<br>saveCityZipCode(city, zipCode);<br></code></pre></td></tr></table></figure><h3 id="5-不要绕太多的弯子"><a href="#5-不要绕太多的弯子" class="headerlink" title="5. 不要绕太多的弯子"></a>5. 不要绕太多的弯子</h3><p>   显式优于隐式</p><h3 id="Bad：-4"><a href="#Bad：-4" class="headerlink" title="Bad："></a>Bad：</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">const locations = [<span class="hljs-string">&quot;Austin&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>, <span class="hljs-string">&quot;San Francisco&quot;</span>];<br>locations.forEach(l =&gt; &#123;<br>  doStuff();<br>  doSomeOtherStuff();<br>  <span class="hljs-regexp">//</span> ...<br>  <span class="hljs-regexp">//</span> ...<br>  <span class="hljs-regexp">//</span> ...<br>  <span class="hljs-regexp">//</span> Wait, what is `l` <span class="hljs-keyword">for</span> again?<br>  dispatch(l);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="Good：-4"><a href="#Good：-4" class="headerlink" title="Good："></a>Good：</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">const locations = [<span class="hljs-string">&quot;Austin&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>, <span class="hljs-string">&quot;San Francisco&quot;</span>];<br>locations.forEach<span class="hljs-params">(<span class="hljs-attr">location</span> =&gt; &#123;</span><br><span class="hljs-params">  doStuff()</span>;<br>  doSomeOtherStuff<span class="hljs-params">()</span>;<br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>  dispatch<span class="hljs-params">(location)</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-不要增加不必要的内容"><a href="#6-不要增加不必要的内容" class="headerlink" title="6. 不要增加不必要的内容"></a>6. 不要增加不必要的内容</h3><p>   当类/对象名已经有意义时，对其变量进行命名不需要再次重复</p><h3 id="Bad：-5"><a href="#Bad：-5" class="headerlink" title="Bad："></a>Bad：</h3><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> Car = &#123;<br>  <span class="hljs-attribute">carMake</span>: <span class="hljs-string">&quot;Honda&quot;</span>,<br>  <span class="hljs-attribute">carModel</span>: <span class="hljs-string">&quot;Accord&quot;</span>,<br>  <span class="hljs-attribute">carColor</span>: <span class="hljs-string">&quot;Blue&quot;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">paintCar</span>(<span class="hljs-params">car, color</span>) </span>&#123;<br>  car.carColor = <span class="hljs-built_in">color</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Good：-5"><a href="#Good：-5" class="headerlink" title="Good："></a>Good：</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs openscad">const Car = &#123;<br>  make: <span class="hljs-string">&quot;Honda&quot;</span>,<br>  model: <span class="hljs-string">&quot;Accord&quot;</span>,<br>  <span class="hljs-built_in">color</span>: <span class="hljs-string">&quot;Blue&quot;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">paintCar</span><span class="hljs-params">(car, color)</span> &#123;</span><br>  car.<span class="hljs-built_in">color</span> = <span class="hljs-built_in">color</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://github.com/ryanmcdermott/clean-code-javascript">clean-code-javascript</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>代码整洁之道JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2021/02/07/%E9%97%AD%E5%8C%85/"/>
    <url>/2021/02/07/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="什么是闭包-（闭包-函数-函数能够访问的自由变量-本质就是外部自由变量（变量对象）保存其作用域链上）"><a href="#什么是闭包-（闭包-函数-函数能够访问的自由变量-本质就是外部自由变量（变量对象）保存其作用域链上）" class="headerlink" title="什么是闭包 ? （闭包 = 函数 + 函数能够访问的自由变量 本质就是外部自由变量（变量对象）保存其作用域链上）"></a>什么是闭包 ? （闭包 = 函数 + 函数能够访问的自由变量 本质就是外部自由变量（变量对象）保存其作用域链上）</h3><ul><li>即使创建它的上下文已经销毁，它依然存在</li><li>在代码中引用了自由变量（指在函数中使用，但既不是函数参数也不是函数局部变量的变量）</li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域链</title>
    <link href="/2021/02/02/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <url>/2021/02/02/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找<br>一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><h3 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h3><p>函数的作用域在函数定义的时候就决定了。<br>这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，<br>可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p><pre><code><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    var a = <span class="hljs-number">1</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>        var b = <span class="hljs-number">2</span><br>        console.<span class="hljs-built_in">log</span>(b) // <span class="hljs-string">[[Scopes]]</span>: Scopes[<span class="hljs-number">1</span>]<br>        // console.<span class="hljs-built_in">log</span>(a) 这里用到外部变量时 <span class="hljs-string">[[Scopes]]</span>: Scope[<span class="hljs-number">2</span>] 形成了闭包<br>    &#125;<br>    bar() <br>&#125;<br>foo()<br><br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量对象</title>
    <link href="/2021/02/02/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/02/02/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>变量对象是与执行上下文有关的数据域，存储了栈上下文中定义的变量和函数</p><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>全局上下文中的变量对象就是全局对象，全局对象是作用域链的头</p><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，<br>只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object，<br>而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>执行上下文代码会分成俩个阶段进行处理</p><ol><li><p>进入执行上下文</p><p> 当进入执行上下文时，这时候还没有执行代码，</p><p> 变量对象会包括：</p><ol><li>函数的所有形参 (如果是函数上下文)</li></ol><ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul><ol start="2"><li>函数声明</li></ol><ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul><ol start="3"><li>变量声明</li></ol><ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li><li><p>代码执行</p></li></ol><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span>第一题<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>    a = <span class="hljs-number">1</span>;<br>&#125;<br><br>foo(); <span class="hljs-comment">// ???</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br>bar(); <span class="hljs-comment">// ???</span><br>第一段会报错：Uncaught <span class="hljs-built_in">ReferenceError</span>: a is not defined。<br><br>第二段会打印：<span class="hljs-number">1</span>。<br><br>这是因为函数中的 <span class="hljs-string">&quot;a&quot;</span> 并没有通过 <span class="hljs-keyword">var</span> 关键字声明，所有不会被存放在 AO 中。<br><br>第一段执行 <span class="hljs-built_in">console</span> 的时候， AO 的值是：<br><br>AO = &#123;<br>    <span class="hljs-built_in">arguments</span>: &#123;<br>        length: <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。<br><br>当第二段执行 <span class="hljs-built_in">console</span> 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 <span class="hljs-number">1</span>。<br><br><span class="hljs-number">2.</span>第二题<br><br><span class="hljs-built_in">console</span>.log(foo);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br>会打印函数，而不是 <span class="hljs-literal">undefined</span> 。<br><br>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，<br>如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>执行上下文栈</title>
    <link href="/2021/02/01/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
    <url>/2021/02/01/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>js引擎并非一行一行的分析和执行程序，而是一段一段的分析执行，当执行一段代码时，会进行一个准备工作，比如变量提升、函数提升</p><h3 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h3><p>js有三种可执行代码（executable code） 全局代码、函数代码、eval代码，当遇到这三种时，就是做准备工作，此时会创建一个对应的<br>上下文（execution context）</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>js有全局上下文和函数上下文</p><p>每个执行上下文，都有三个重要的属性：变量对象（Variable object， VO），作用域链（Scope chain），this</p><h3 id="执行上下文栈-1"><a href="#执行上下文栈-1" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>js引擎创建了执行上下文栈（Execution context stack， ECS）来管理执行上下文 </p><p>当js开始执行代码的时候，最先遇到的就是全局代码，所以程序开始的时候就会向执行上下文栈压入一个全局执行上下文，只有程序结束的时候，<br>ECStack才会被清空，所以ECStack最低部永远有个全局执行上下文</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法作用域和动态作用域</title>
    <link href="/2021/01/29/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2021/01/29/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一套用来存储变量和访问变量的规则</p><h3 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h3><p>JavaScript采用的是静态作用域，函数的作用域在函数定义的时候就决定了，而与词法作用域相对的是动态作用域，函数的作用域是在函数调用时才决定的</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>    foo()<br>&#125;<br>bar() <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">/* 分析上面代码执行过程：因为js采用的是词法作用域， </span><br><span class="hljs-comment">执行foo函数，先从函数内部查找是否有局部变量a，如果</span><br><span class="hljs-comment">没有，就根据书写的位置，查找上一层的代码，也就是a等</span><br><span class="hljs-comment">于1，所以会打印1， 如果是动态作用域，会从调用函数的</span><br><span class="hljs-comment">作用域查找变量，也就是bar的内部，会打印2 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型到原型链</title>
    <link href="/2021/01/17/%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2021/01/17/%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="原型到原型链"><a href="#原型到原型链" class="headerlink" title="原型到原型链"></a>原型到原型链</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每个函数都有一个prototype属性，这个属性指向了一个对象，这个对象正是用该构造函数创建的实例的原型</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// prototype 是函数才有的属性</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;<br>Person.prototype.alias = <span class="hljs-string">&#x27;monster&#x27;</span><br><span class="hljs-keyword">const</span> michael = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-keyword">const</span> andrew = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-built_in">console</span>.log(michael.alias) <span class="hljs-comment">// monster</span><br><span class="hljs-built_in">console</span>.log(andrew.alias) <span class="hljs-comment">// monster</span><br></code></pre></td></tr></table></figure></code></pre><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p>每一个JavaScritp对象(null除外)都有一个__proto__属性，这个属性会指向该对象的原型</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;<br><span class="hljs-keyword">const</span> michael = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-built_in">console</span>.log(michael.__proto__ === Person.prototype) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>原型： 每一个JavaScript对象(null除外)在创建的时候会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性</code></pre><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>每个原型都有一个 constructor 属性指向关联的构造函数</p><pre><code><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment"></span></span><br><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><br><span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">(Person === Person.prototype.<span class="hljs-keyword">constructor</span>)</span>;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></code></pre><h3 id="如下图-对象之间形成了一条原型链"><a href="#如下图-对象之间形成了一条原型链" class="headerlink" title="如下图 对象之间形成了一条原型链"></a>如下图 对象之间形成了一条原型链</h3><p><img src="/images/prototypeChain.png"></p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
