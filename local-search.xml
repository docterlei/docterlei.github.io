<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>bubbleSort</title>
    <link href="/2021/03/24/bubbleSort/"/>
    <url>/2021/03/24/bubbleSort/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>循环数组 比较当前元素和下一个元素 如果当前元素比下一个元素大， 向上冒泡 这样循环一次之后最后一个数就是数组最大大数，下一次循环继续上面大操作，不循环已经排好序的数</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">var arr = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]<br><br>for(var i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; arr.length - 1; i++) &#123;</span><br>    for(var <span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; arr.length - i; j++) &#123;</span><br>        let temp;<br>        if(arr[<span class="hljs-keyword">j] </span>&gt; arr[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>]) &#123;<br>            temp = arr[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>]<br>            arr[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>] = arr[<span class="hljs-keyword">j]</span><br><span class="hljs-keyword"> </span>           arr[<span class="hljs-keyword">j] </span>= temp<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="优化外层循环"><a href="#优化外层循环" class="headerlink" title="优化外层循环"></a>优化外层循环</h3><blockquote><p>利用外层循环 当内层循环中没有发生冒泡 说明排序已经完成 直接在本来循环后终止循环</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> isBubble = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - i; j++) &#123;<br>        <span class="hljs-keyword">let</span> temp;<br>        <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            temp = arr[j + <span class="hljs-number">1</span>]<br>            arr[j + <span class="hljs-number">1</span>] = arr[j]<br>            arr[j] = temp<br>            isBubble = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(isBubble) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="优化内层循环"><a href="#优化内层循环" class="headerlink" title="优化内层循环"></a>优化内层循环</h3><blockquote><p>利用内层循环 记录下每次内层循环最后一次发生冒泡的索引 后面没有发生冒泡 表示后面数排序已经完成 下次循环就不循环后面的了</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]<br><span class="hljs-keyword">let</span> lastExchangeIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最后一次交换的位置</span><br><span class="hljs-keyword">let</span> sortBorder = arr.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 无序数列的边界 每次只需要比到这里</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> isBubble = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; sortBorder; j++) &#123;<br>        <span class="hljs-keyword">let</span> temp;<br>        <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            temp = arr[j + <span class="hljs-number">1</span>]<br>            arr[j + <span class="hljs-number">1</span>] = arr[j]<br>            arr[j] = temp<br>            lastExchangeIndex = j<br>            isBubble = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    sortBorder = lastExchangeIndex<br>    <span class="hljs-keyword">if</span>(isBubble) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>utils</title>
    <link href="/2021/03/16/utils-1/"/>
    <url>/2021/03/16/utils-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>utils</title>
    <link href="/2021/03/16/utils/"/>
    <url>/2021/03/16/utils/</url>
    
    <content type="html"><![CDATA[<h3 id="1-获取一个随机布尔值"><a href="#1-获取一个随机布尔值" class="headerlink" title="1. 获取一个随机布尔值"></a>1. 获取一个随机布尔值</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const randomBoolean = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Math</span>.random() &gt;= <span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure><h3 id="2-检查日期是否为工作日"><a href="#2-检查日期是否为工作日" class="headerlink" title="2. 检查日期是否为工作日"></a>2. 检查日期是否为工作日</h3><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">get</span><span class="hljs-built_in">Day</span>()返回一星期中的某一天（<span class="hljs-number">0</span><span class="hljs-number">-6</span>）<br><span class="hljs-keyword">get</span><span class="hljs-built_in">Date</span>()返回一个月中的某一天（<span class="hljs-number">1</span><span class="hljs-number">-31</span>）<br><span class="hljs-keyword">const</span> isWeekday = (date) =&gt; date.<span class="hljs-keyword">get</span><span class="hljs-built_in">Day</span>() % <span class="hljs-number">6</span> !== <span class="hljs-number">0</span> <br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">is</span><span class="hljs-built_in">Weekday</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()))<br></code></pre></td></tr></table></figure><h3 id="3-检查当前-Tab-页是否在前台"><a href="#3-检查当前-Tab-页是否在前台" class="headerlink" title="3. 检查当前 Tab 页是否在前台"></a>3. 检查当前 Tab 页是否在前台</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const isBroserTabInView = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">document</span>.hidden<br><span class="hljs-built_in">console</span>.log(isBroserTabInView())<br></code></pre></td></tr></table></figure><h3 id="4-检查数字是否为偶数"><a href="#4-检查数字是否为偶数" class="headerlink" title="4. 检查数字是否为偶数"></a>4. 检查数字是否为偶数</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const isEven = <span class="hljs-function"><span class="hljs-params">(num)</span> =&gt;</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br><span class="hljs-built_in">console</span>.log(isEven(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h3 id="5-滚动到页面顶部"><a href="#5-滚动到页面顶部" class="headerlink" title="5. 滚动到页面顶部"></a>5. 滚动到页面顶部</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const goTop = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">window</span>.scrollTo(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.log(goTop())<br></code></pre></td></tr></table></figure><h3 id="6-获取所有参数平均值"><a href="#6-获取所有参数平均值" class="headerlink" title="6. 获取所有参数平均值"></a>6. 获取所有参数平均值</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const getAverage = <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> args.reduce(<span class="hljs-function"><span class="hljs-params">(acc, cur)</span> =&gt;</span> acc + cur) / args.length<br><span class="hljs-built_in">console</span>.log(getAverage(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CommonJs和EsModule的区别</title>
    <link href="/2021/03/16/CommonJs%E5%92%8CEsModule%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/03/16/CommonJs%E5%92%8CEsModule%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h3><ul><li>CommonJS 模块输出的是一个值的拷贝（导出值是拷贝，可以修改值，并不会影响到原文件中的值），<br>  ES6 模块输出的是值的引用（导出值和引用值之间存在引用关系，是只读的，不可修改，如果要修改，可以在原文件中写一个修改函数，然后导出此函数，供调用修改此值）</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出引用（ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，<br>  遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，<br>  到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，<br>  import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块） </li><li>CommonJS 模块的require()是同步加载模块，ES6 模块的import 在<a href="https://segmentfault.com/q/1010000005680390">运行时时同步还是异步实现，取决于loader api</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP</title>
    <link href="/2021/03/08/TCP/"/>
    <url>/2021/03/08/TCP/</url>
    
    <content type="html"><![CDATA[<h3 id="建立-TCP-连接-，而-HTTPS-在-TCP-三次握手之后，还需进行-SSL-TSL-的握手过程，才可进入加密报文传输"><a href="#建立-TCP-连接-，而-HTTPS-在-TCP-三次握手之后，还需进行-SSL-TSL-的握手过程，才可进入加密报文传输" class="headerlink" title="建立 TCP 连接 ，而 HTTPS 在 TCP 三次握手之后，还需进行 SSL / TSL 的握手过程，才可进入加密报文传输"></a>建立 TCP 连接 ，而 HTTPS 在 TCP 三次握手之后，还需进行 SSL / TSL 的握手过程，才可进入加密报文传输</h3><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><pre><code>1. 第一次握手： 客户端会随机初始化序号 （clent_isn），将此序号置于 TCP 首部的 序号 字段中， 同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文 发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态2. 服务端收到客户端的 SYN 报文后， 首先服务端也初始化自己的序号（server_isn），将此序号填入 TCP 首部的序号字段中， 其次把 TCP 首部的 确认应答号 字段填入 client_isn + 1,接着把 SYN 和 ACK 标志位置为 1， 最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态3. 客户端收到服务端报文后，还要向服务端回应一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1， 其次 确认应答号 字段填入 server_isn + 1,最后把报文发送给服务端，这次报文可以携带数据，之后客户端处于 ESTABLISHED，服务端收到客户端的应答报文后，也进入 ESTABLISHED</code></pre><h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h3><pre><code>在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题**。</code></pre><h3 id="确认应答号"><a href="#确认应答号" class="headerlink" title="确认应答号"></a>确认应答号</h3><pre><code>指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决不丢包的问题**。</code></pre><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><pre><code>1. 客户端打算关闭连接， 此时会发送一个 TCP 首部 FIN 标志位为 1 的报文， 即 FIN 报文， 之后客户端进入 FIN_WAIT_1 状态。2. 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态3. 客户端收到服务端的 ACK 应答报文后，进入 FIN_WAIT_2 状态4. 等待服务端处理完数据后， 也向客户端发送 FIN 报文， 之后服务端进入 LAST_ACK 状态5. 客户端收到服务端的 FIN 报文后， 回一个 ACK 应答报文， 之后进入 TIME_WAIT状态6. 服务器收到了 ACK 应答报文后，就进入了 CLOSE 状态， 至此服务端已经完成连接的关闭7. 客户端在经过 2MSL（60秒） 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭因为每个方向都需要一个 FIN 和 一个 ACK，因此通常被称为 四次挥手， 有一点需要注意： **主动关闭连接的 才有 TIME_WAIT状态**</code></pre><h4 id="为什么挥手需要四次"><a href="#为什么挥手需要四次" class="headerlink" title="为什么挥手需要四次"></a>为什么挥手需要四次</h4><pre><code>1. 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还是能接收数据2. 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文， 而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送， 从而比三次握手导致多了一次</code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://mp.weixin.qq.com/s/bHZ2_hgNQTKFZpWMCfUH9A">实战！我用“大白鲨”让你看见 TCP</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS域名解析</title>
    <link href="/2021/03/01/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/03/01/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><h3 id="DNS-域名的层级关系树一个树状结构"><a href="#DNS-域名的层级关系树一个树状结构" class="headerlink" title="DNS 域名的层级关系树一个树状结构"></a>DNS 域名的层级关系树一个树状结构</h3><ul><li>根 DNS 服务器</li><li>顶级域 DNS 服务器（.com,.cn…）</li><li>权威 DNS 服务器（163.com）</li></ul><p><img src="/images/dns.jpeg" alt="DNS树状结构"></p><h3 id="DNS-域名查找过程"><a href="#DNS-域名查找过程" class="headerlink" title="DNS 域名查找过程"></a>DNS 域名查找过程</h3><blockquote><p>根域的 DNS 服务器信息保存在互联网所有的 DNS 服务器中</p></blockquote><ol><li><p>在客户端输入 URL 后， 会有一个查找过程， 这个过程中任何一步找到了都会结束查找流程</p><ol><li>浏览器缓存</li><li>本地 hosts 文件</li><li>本地 DNS 服务器缓存查找</li></ol></li><li><p>如果上一步没找到 会进行如下查找：</p><ol><li>本地 DNS 服务器会去问它的根域名服务器，“老大，能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？“<br> 根域名服务器不直接用于域名解析，但它能指明一条道路</li><li>根 DNS 服务器发现后置是 .com 后，会把 .com 顶级域名服务器 IP 地址返回回来</li><li>本地 DNS 收到顶级域名服务器 IP 后， 发起请求问 “老二， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP地址吗”</li><li>顶级域名服务器会返回权威服务器 IP 地址</li><li>本地 DNS 收到权威 IP 后，发起请求问 “老三， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP地址吗”</li><li>权威 DNS 服务器查询后将对应的 IP 地址告诉本地 DNS</li><li>本地 DNS 再将 IP 地址返回客户端，然后客户端和目标建立连接</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么尽量不要用index作为key</title>
    <link href="/2021/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E7%94%A8index%E4%BD%9C%E4%B8%BAkey/"/>
    <url>/2021/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E7%94%A8index%E4%BD%9C%E4%B8%BAkey/</url>
    
    <content type="html"><![CDATA[<h3 id="1-因为这样做会导致性能变差-这个策略在元素不进行重新排序时比较合适，但一旦有顺序修改，diff-就会变得慢-因为组件的子元素会重新渲染"><a href="#1-因为这样做会导致性能变差-这个策略在元素不进行重新排序时比较合适，但一旦有顺序修改，diff-就会变得慢-因为组件的子元素会重新渲染" class="headerlink" title="1.因为这样做会导致性能变差(这个策略在元素不进行重新排序时比较合适，但一旦有顺序修改，diff 就会变得慢, 因为组件的子元素会重新渲染)"></a>1.因为这样做会导致性能变差(这个策略在元素不进行重新排序时比较合适，但一旦有顺序修改，diff 就会变得慢, 因为组件的子元素会重新渲染)</h3><ol><li>index为key：<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">变化前数组的值是[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]，<span class="hljs-built_in">key</span>就是对应的下标：<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>,   <br>变化后数组的值是[<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]，<span class="hljs-built_in">key</span>对应的下标也是：<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span><br><br>那么<span class="hljs-built_in">diff</span>算法在变化前的数组找到<span class="hljs-built_in">key</span> =<span class="hljs-number">0</span>的值是<span class="hljs-number">1</span>，在变化后数组里找到的<span class="hljs-built_in">key</span>=<span class="hljs-number">0</span>的值是<br>因为子元素不一样就重新删除并更新<br></code></pre></td></tr></table></figure></li><li>唯一key<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">变化前数组的值是[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]，<span class="hljs-built_in">key</span>就是对应的下标：id0，id1，id2，id3<br>变化后数组的值是[<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]，<span class="hljs-built_in">key</span>对应的下标也是：id3，id2，id1，id0<br><br>那么<span class="hljs-built_in">diff</span>算法在变化前的数组找到<span class="hljs-built_in">key</span> =id0的值是<span class="hljs-number">1</span>，在变化后数组里找到的<span class="hljs-built_in">key</span>=id0的值也是<span class="hljs-number">1</span>，<br>因为子元素相同，就不删除并更新，只做移动操作，这就提升了性能<br></code></pre></td></tr></table></figure><h3 id="2-还可能引起组件状态的问题-可查看下面的例子"><a href="#2-还可能引起组件状态的问题-可查看下面的例子" class="headerlink" title="2.还可能引起组件状态的问题,可查看下面的例子"></a>2.还可能引起组件状态的问题,可查看下面的例子</h3><a href="https://codesandbox.io/s/amazing-ramanujan-ohkb0?file=/src/App.js">使用索引作为key的负面影响</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>react相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从输入url到获得页面到过程</title>
    <link href="/2021/02/23/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E5%88%B0%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/02/23/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E5%88%B0%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="从输入url到获得页面到过程"><a href="#从输入url到获得页面到过程" class="headerlink" title="从输入url到获得页面到过程"></a>从输入url到获得页面到过程</h2><h3 id="1-构建请求"><a href="#1-构建请求" class="headerlink" title="1. 构建请求"></a>1. 构建请求</h3><blockquote><p>使用浏览器进行请求后，浏览器会先判断地址栏中输入的是 query（关键字）还是URL，</p><blockquote><ol><li>如果是URL，则把URL转发给网络进程，网络进程会构建请求行信息，构建好之后，浏览器就准备发起网络请求</li><li>如果是关键字，浏览器会自动生成一个带有我们搜索关键字的 URL，然后向默认的搜索引擎发起连接请求，后面和输入 URL 一样</li></ol></blockquote></blockquote><h3 id="2-查找强缓存"><a href="#2-查找强缓存" class="headerlink" title="2. 查找强缓存"></a>2. 查找强缓存</h3><blockquote><p>浏览器在发起真正的网络请求前，会先检查浏览器的强缓存，如果命中，直接返回对应资源文件的副本，否则进入下一步</p></blockquote><h3 id="3-DNS解析"><a href="#3-DNS解析" class="headerlink" title="3. DNS解析"></a>3. DNS解析</h3><blockquote><p>发起真正的网络请求前，首先需要进行 DNS 解析，目的就是找到 URL 对应的服务器的 IP 地址</p></blockquote><h3 id="4-建立-TCP-连接-如果是-HTTP-，三次握手之后便可进行-HTTP-的报文传输，而-HTTPS-在-TCP-三次握手之后，还需要进行-SSL-TSL-的握手过程，然后才可进行加密报文传输"><a href="#4-建立-TCP-连接-如果是-HTTP-，三次握手之后便可进行-HTTP-的报文传输，而-HTTPS-在-TCP-三次握手之后，还需要进行-SSL-TSL-的握手过程，然后才可进行加密报文传输" class="headerlink" title="4. 建立 TCP 连接 如果是 HTTP ，三次握手之后便可进行 HTTP 的报文传输，而 HTTPS 在 TCP 三次握手之后，还需要进行 SSL / TSL 的握手过程，然后才可进行加密报文传输"></a>4. 建立 TCP 连接 如果是 HTTP ，三次握手之后便可进行 HTTP 的报文传输，而 HTTPS 在 TCP 三次握手之后，还需要进行 SSL / TSL 的握手过程，然后才可进行加密报文传输</h3><blockquote><p>建立了 TCP 连接， 浏览器就可以和服务器进行通信了，HTTP 中的数据就是在这个通信过程中传输的</p></blockquote><h3 id="5-发送请求"><a href="#5-发送请求" class="headerlink" title="5. 发送请求"></a>5. 发送请求</h3><h3 id="6-查找协商缓存"><a href="#6-查找协商缓存" class="headerlink" title="6. 查找协商缓存"></a>6. 查找协商缓存</h3><h3 id="7-断开TCP连接"><a href="#7-断开TCP连接" class="headerlink" title="7. 断开TCP连接"></a>7. 断开TCP连接</h3><h3 id="8-浏览器渲染"><a href="#8-浏览器渲染" class="headerlink" title="8. 浏览器渲染"></a>8. 浏览器渲染</h3><h3 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h3><p><img src="/images/getPageProcess.png" alt="从输入url到获得页面到过程"></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xss攻击</title>
    <link href="/2021/02/23/xss%E6%94%BB%E5%87%BB/"/>
    <url>/2021/02/23/xss%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><blockquote><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全</p></blockquote><h3 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h3><ol><li><p>存储型</p><ul><li>概念：存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，它不需要用户手动触发</li><li>攻击步骤：<ol><li>击者将恶意代码提交到目标网站的数据库中</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ol></li><li>攻击方法：常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</li></ul></li><li><p>反射型</p><ul><li>概念：反射型XSS也被称为非持久性XSS。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行</li><li>攻击步骤：<ol><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ol></li><li>攻击方法：常见于通过 URL 传递参数的功能，如网站搜索、跳转等</li></ul></li><li><p>DOM型</p><ul><li>概念：DOM 型 XSS 攻击中，<strong>取出和执行</strong>恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于<strong>服务端</strong>的安全漏洞</li><li>攻击步骤：<ol><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的 URL</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ol></li><li>攻击方法：DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</li></ul></li></ol><h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><ol><li>对输入(和URL参数)进行过滤，对输出进行编码。</li><li>内容安全策略（内容安全策略）<blockquote><p>CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置</p></blockquote></li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://tech.meituan.com/2018/09/27/fe-security.html">如何防止XSS攻击?</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html">Content Security Policy 入门教程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络模型</title>
    <link href="/2021/02/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/02/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="OSI-和-TCP-IP模型对比"><a href="#OSI-和-TCP-IP模型对比" class="headerlink" title="OSI 和 TCP/IP模型对比"></a>OSI 和 TCP/IP模型对比</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60be38880ed346258a8fd4c59538d39f~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="TCP-IP-模型对应的相关协议及对应数据单位"><a href="#TCP-IP-模型对应的相关协议及对应数据单位" class="headerlink" title="TCP/IP 模型对应的相关协议及对应数据单位"></a>TCP/IP 模型对应的相关协议及对应数据单位</h3><ul><li>应用层：<ul><li>HTTP, FTP</li><li>报文(message)</li></ul></li><li>传输层：<ul><li>TCP, UDP</li><li>数据段(segment)</li></ul></li><li>网络层：<ul><li>IP, ICMP </li><li>分组或者数据包(packets)</li></ul></li><li>数据链路层：<ul><li>ARP, RARP</li><li>帧(frame) 物理层传输的单位是比特(bit)</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http缓存</title>
    <link href="/2021/02/22/http%E7%BC%93%E5%AD%98/"/>
    <url>/2021/02/22/http%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP缓存分为强制缓存和协商缓存"><a href="#HTTP缓存分为强制缓存和协商缓存" class="headerlink" title="HTTP缓存分为强制缓存和协商缓存"></a>HTTP缓存分为强制缓存和协商缓存</h2><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>有俩个字段来表明失效规则（Expires / Cache-control）</p><ul><li>Expires的值表示服务端返回的到期时间，即下一次请求，如果时间小于服务器到期时间 直接使用缓存数据 <ol><li>Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，一般用来向下兼容</li><li>到期时间是由服务端生成的，如果修改了客户端的时间，就会导致缓存命中的误差</li></ol></li><li>Cache-control 有如下几个值：<ol><li>private 客户端可以缓存</li><li>public 客户端和代理服务器都要缓存</li><li>max-age 如果值为 800， 意思就是缓存的内容将在 800 秒后失效</li><li>no-cache 需使用协商缓存来验证缓存数据</li><li>no-store 所有内容都不会缓存，<strong>强制缓存和协商缓存都不会触发</strong></li></ol></li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>对比强制缓存，协商缓存会<strong>发送请求</strong>到服务器 </p><ul><li>Last-Modified / If-Modified-Since<ul><li>Last-Modified 服务器在相应请求时，告诉浏览器资源的最后修改时间</li><li>If-Modified-Since 再次请求服务器时，浏览器会将上次请求到的Last-Modified的值作为 If-Modified-Since值发送给服务器，服务器接受后，发现有If-Modified-Since字段，则与被请求资源的最后修改时间进行对比，如果资源的最后修改时间大于If-Modified-Since的值，说明资源被改动过，则响应整体的资源内容。如果不大于，说明资源无修改 则相应 <strong>HTTP 304</strong>，告诉浏览器继续使用缓存的数据</li></ul></li><li>Etag / If-None-Match(优先级高于Last-Modified / If-Modified-Since)<ul><li>Etag 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）</li><li>If-None-Match 再次请求服务器时，浏览器会将上次请求到的Etag的值作为 If-None-Match值发送给服务器，服务器接受后，发现有If-None-Match字段，则与被请求资源的最后修改时间进行对比，不同，说明资源被改动过，则响应整体的资源内容。相同，说明资源无修改 则相应 <strong>HTTP 304</strong>，告诉浏览器继续使用缓存的数据</li></ul></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>箭头函数</title>
    <link href="/2021/02/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <url>/2021/02/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="1-没有-this-所以需要通过查找作用域链来确定-this-的值。这就意味着如果箭头函数被非箭头函数包含，this-绑定的就是最近一层非箭头函数的-this"><a href="#1-没有-this-所以需要通过查找作用域链来确定-this-的值。这就意味着如果箭头函数被非箭头函数包含，this-绑定的就是最近一层非箭头函数的-this" class="headerlink" title="1. 没有 this 所以需要通过查找作用域链来确定 this 的值。这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this"></a>1. 没有 this 所以需要通过查找作用域链来确定 this 的值。这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this</h3><h3 id="2-没有-arguments"><a href="#2-没有-arguments" class="headerlink" title="2. 没有 arguments"></a>2. 没有 arguments</h3><h3 id="3-不能通过-new-关键字调用"><a href="#3-不能通过-new-关键字调用" class="headerlink" title="3. 不能通过 new 关键字调用"></a>3. 不能通过 new 关键字调用</h3><h3 id="4-没有原型"><a href="#4-没有原型" class="headerlink" title="4. 没有原型"></a>4. 没有原型</h3><h3 id="5-没有-super"><a href="#5-没有-super" class="headerlink" title="5. 没有 super"></a>5. 没有 super</h3><blockquote><p>this 和 super 的区别：<br>  this 关键词指向函数所在的当前对象<br>  super <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super">关键字用于访问和调用一个对象的副对象上的函数</a><br>  继承的子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象</p></blockquote><h3 id="6-没有-new-target"><a href="#6-没有-new-target" class="headerlink" title="6. 没有 new.target"></a>6. 没有 new.target</h3><blockquote><p>因为不能使用 new 调用，所以也没有 new.target 值。<br>new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，<br>该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。<br>如果构造函数不是通过new命令或Reflect.construct()调用的，<br>new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>es6相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类数组对象与arguments</title>
    <link href="/2021/02/21/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8Earguments/"/>
    <url>/2021/02/21/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8Earguments/</url>
    
    <content type="html"><![CDATA[<h2 id="类数组对象与arguments"><a href="#类数组对象与arguments" class="headerlink" title="类数组对象与arguments"></a>类数组对象与arguments</h2><h3 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h3><blockquote><p>拥有一个 length 属性和若干个索引属性的对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;sex&#x27;</span>]<br><br><span class="hljs-keyword">var</span> arrLike = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;sex&#x27;</span>,<br>    length: <span class="hljs-string">&#x27;3&#x27;</span><br>&#125;<br>为什么交类数组对象？ 因为它的读写，获取长度，<span class="hljs-keyword">for</span> 遍历和数组都一样，区别是不能用数组的方法<br></code></pre></td></tr></table></figure><h3 id="类数组调用数组方法"><a href="#类数组调用数组方法" class="headerlink" title="类数组调用数组方法"></a>类数组调用数组方法</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">var arrLike = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;sex&#x27;</span>,<br>    length: <span class="hljs-string">&#x27;3&#x27;</span><br>&#125;<br><br>Array.prototype.join.call(arrLike, <span class="hljs-string">&#x27;&amp;&#x27;</span>) <span class="hljs-regexp">//</span> name&amp;age&amp;sex<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. slice类数组转数组<br>Array.prototype.slice.call(arrayLike); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>] <br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. splice类数组转数组<br>Array.prototype.splice.call(arrayLike, <span class="hljs-number">0</span>); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>] <br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span>. ES6 Array.from<br>Array.from(arrayLike); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>]<br><span class="hljs-regexp">//</span> <span class="hljs-number">4</span>. concat结合apply<br>Array.prototype.concat.apply([], arrayLike) <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>]<br><br>Array.prototype.map.call(arrayLike, <span class="hljs-keyword">function</span>(item)&#123;<br>    return item.toUpperCase();<br>&#125;); <br><span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;NAME&quot;</span>, <span class="hljs-string">&quot;AGE&quot;</span>, <span class="hljs-string">&quot;SEX&quot;</span>]<br><br>Arguments对象就是类素组对象，在客户端 JavaScript 中，一些 DOM 方法也返回类数组对象<br><br></code></pre></td></tr></table></figure><h3 id="Arguments对象"><a href="#Arguments对象" class="headerlink" title="Arguments对象"></a>Arguments对象</h3><blockquote><p>Arguments 对象只定义在函数体中，包括了函数的参数和其它属性，在函数体中，arguments 指代该函数的 Arguments 对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<br>&#125;<br><br>foo(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><p>打印结果如下：<br><img src="/images/Arguments.jpeg"></p><h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scilab">Arguments对象的<span class="hljs-built_in">length</span>属性，表示实参的长度，举个例子：<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(b, c, d)</span>&#123;</span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;实参的长度为：&quot;</span> + arguments.<span class="hljs-built_in">length</span>)<br>&#125;<br><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;形参的长度为：&quot;</span> + foo.<span class="hljs-built_in">length</span>)<br><br>foo(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 形参的长度为：3</span><br><span class="hljs-comment">// 实参的长度为：1</span><br><br></code></pre></td></tr></table></figure><h3 id="callee-属性-指向调用函数自身"><a href="#callee-属性-指向调用函数自身" class="headerlink" title="callee 属性 指向调用函数自身"></a>callee 属性 指向调用函数自身</h3><h3 id="Symbol-Symbol-iterator-它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署-Iterator-接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）"><a href="#Symbol-Symbol-iterator-它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署-Iterator-接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）" class="headerlink" title="Symbol(Symbol.iterator) 它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）"></a>Symbol(Symbol.iterator) 它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）</h3><h3 id="Argument和对应参数的绑定"><a href="#Argument和对应参数的绑定" class="headerlink" title="Argument和对应参数的绑定"></a>Argument和对应参数的绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name, age, sex, hobbit</span>) </span>&#123;<br><br>    <span class="hljs-built_in">console</span>.log(name, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// name name</span><br><br>    <span class="hljs-comment">// 改变形参</span><br>    name = <span class="hljs-string">&#x27;new name&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(name, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// new name new name</span><br><br>    <span class="hljs-comment">// 改变arguments</span><br>    <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;new age&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(age, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// new age new age</span><br><br>    <span class="hljs-comment">// 测试未传入的是否会绑定</span><br>    <span class="hljs-built_in">console</span>.log(sex); <span class="hljs-comment">// undefined</span><br><br>    sex = <span class="hljs-string">&#x27;new sex&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(sex, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>]); <span class="hljs-comment">// new sex undefined</span><br><br>    <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;new hobbit&#x27;</span>;<br><br>    <span class="hljs-built_in">console</span>.log(hobbit, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>]); <span class="hljs-comment">// undefined new hobbit</span><br><br>&#125;<br><br>foo(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>)<br>传入的参数，实参和 <span class="hljs-built_in">arguments</span> 的值会共享，当没有传入时，实参与 <span class="hljs-built_in">arguments</span> 值不会共享<br><br>除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 <span class="hljs-built_in">arguments</span> 是不会共享的。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参数传递</title>
    <link href="/2021/02/07/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    <url>/2021/02/07/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="1-按值传递"><a href="#1-按值传递" class="headerlink" title="1.按值传递"></a>1.按值传递</h3><p>ECMAScript中所有函数的参数都是按值传递的 也就是说把函数外部的值复制给函数内部的参数，就是把值从一个变量复制到另一个变量 如下：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">v</span>) </span>&#123;<br>      v = <span class="hljs-number">2</span>;<br>      <span class="hljs-built_in">console</span>.log(v) <span class="hljs-comment">//2</span><br>  &#125;<br>  foo(a)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br><br>当传递 a 到函数 foo 中，相当于拷贝量一份 a 的值给了 v 函数中修改的都是 v 的值 而不会影响原来的 a 值<br><br></code></pre></td></tr></table></figure></p><h3 id="2-引用传递"><a href="#2-引用传递" class="headerlink" title="2. 引用传递"></a>2. 引用传递</h3><p>传递给函数的是对象的引用 函数内部对参数任何修改都会影响该对象的值 因为俩者引用的是同一个对象</p>   <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> obj = <span class="hljs-comment">&#123; a: 1&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(param)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    param.a = 2</span></span><br><span class="hljs-function"><span class="hljs-comment">    console.log(params.a) //2</span></span><br><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">(obj)</span></span><br><span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">(obj.a)</span> <span class="hljs-comment">// 2</span></span><br><span class="hljs-function">我们上面说 <span class="hljs-title">js</span> 是按值传递 现在这种情况 像是按引用传递了 其实这种是按共享传递</span><br></code></pre></td></tr></table></figure><h3 id="按共享传递"><a href="#按共享传递" class="headerlink" title="按共享传递"></a>按共享传递</h3><p>按共享传递 传递给函数的是传递对象的引用的副本  如下：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">param</span>) </span>&#123;<br>    param = <span class="hljs-number">2</span><br>    <span class="hljs-built_in">console</span>.log(param) <span class="hljs-comment">// 2</span><br>&#125;<br>foo(obj)<br><span class="hljs-built_in">console</span>.log(obj) <span class="hljs-comment">// &#123;a: 1&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>参数如果是基本类型是按值传递 如果是引用类型是按共享传递</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2021/02/07/%E9%97%AD%E5%8C%85/"/>
    <url>/2021/02/07/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="什么是闭包-（闭包-函数-函数能够访问的自由变量-本质就是外部自由变量（变量对象）保存其作用域链上）"><a href="#什么是闭包-（闭包-函数-函数能够访问的自由变量-本质就是外部自由变量（变量对象）保存其作用域链上）" class="headerlink" title="什么是闭包 ? （闭包 = 函数 + 函数能够访问的自由变量 本质就是外部自由变量（变量对象）保存其作用域链上）"></a>什么是闭包 ? （闭包 = 函数 + 函数能够访问的自由变量 本质就是外部自由变量（变量对象）保存其作用域链上）</h3><ul><li>即使创建它的上下文已经销毁，它依然存在</li><li>在代码中引用了自由变量（指在函数中使用，但既不是函数参数也不是函数局部变量的变量）</li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域链</title>
    <link href="/2021/02/02/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <url>/2021/02/02/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找<br>一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><h3 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h3><p>函数的作用域在函数定义的时候就决定了。<br>这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，<br>可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p><pre><code><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    var a = <span class="hljs-number">1</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>        var b = <span class="hljs-number">2</span><br>        console.<span class="hljs-built_in">log</span>(b) // <span class="hljs-string">[[Scopes]]</span>: Scopes[<span class="hljs-number">1</span>]<br>        // console.<span class="hljs-built_in">log</span>(a) 这里用到外部变量时 <span class="hljs-string">[[Scopes]]</span>: Scope[<span class="hljs-number">2</span>] 形成了闭包<br>    &#125;<br>    bar() <br>&#125;<br>foo()<br><br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量对象</title>
    <link href="/2021/02/02/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/02/02/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>变量对象是与执行上下文有关的数据域，存储了栈上下文中定义的变量和函数</p><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>全局上下文中的变量对象就是全局对象，全局对象是作用域链的头</p><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，<br>只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object，<br>而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>执行上下文代码会分成俩个阶段进行处理</p><ol><li><p>进入执行上下文</p><p> 当进入执行上下文时，这时候还没有执行代码，</p><p> 变量对象会包括：</p><ol><li>函数的所有形参 (如果是函数上下文)</li></ol><ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul><ol start="2"><li>函数声明</li></ol><ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul><ol start="3"><li>变量声明</li></ol><ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li><li><p>代码执行</p></li></ol><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span>第一题<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>    a = <span class="hljs-number">1</span>;<br>&#125;<br><br>foo(); <span class="hljs-comment">// ???</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br>bar(); <span class="hljs-comment">// ???</span><br>第一段会报错：Uncaught <span class="hljs-built_in">ReferenceError</span>: a is not defined。<br><br>第二段会打印：<span class="hljs-number">1</span>。<br><br>这是因为函数中的 <span class="hljs-string">&quot;a&quot;</span> 并没有通过 <span class="hljs-keyword">var</span> 关键字声明，所有不会被存放在 AO 中。<br><br>第一段执行 <span class="hljs-built_in">console</span> 的时候， AO 的值是：<br><br>AO = &#123;<br>    <span class="hljs-built_in">arguments</span>: &#123;<br>        length: <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。<br><br>当第二段执行 <span class="hljs-built_in">console</span> 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 <span class="hljs-number">1</span>。<br><br><span class="hljs-number">2.</span>第二题<br><br><span class="hljs-built_in">console</span>.log(foo);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br>会打印函数，而不是 <span class="hljs-literal">undefined</span> 。<br><br>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，<br>如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>执行上下文栈</title>
    <link href="/2021/02/01/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
    <url>/2021/02/01/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>js引擎并非一行一行的分析和执行程序，而是一段一段的分析执行，当执行一段代码时，会进行一个准备工作，比如变量提升、函数提升</p><h3 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h3><p>js有三种可执行代码（executable code） 全局代码、函数代码、eval代码，当遇到这三种时，就是做准备工作，此时会创建一个对应的<br>上下文（execution context）</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>js有全局上下文和函数上下文</p><p>每个执行上下文，都有三个重要的属性：变量对象（Variable object， VO），作用域链（Scope chain），this</p><h3 id="执行上下文栈-1"><a href="#执行上下文栈-1" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>js引擎创建了执行上下文栈（Execution context stack， ECS）来管理执行上下文 </p><p>当js开始执行代码的时候，最先遇到的就是全局代码，所以程序开始的时候就会向执行上下文栈压入一个全局执行上下文，只有程序结束的时候，<br>ECStack才会被清空，所以ECStack最低部永远有个全局执行上下文</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法作用域和动态作用域</title>
    <link href="/2021/01/29/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2021/01/29/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一套用来存储变量和访问变量的规则</p><h3 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h3><p>JavaScript采用的是静态作用域，函数的作用域在函数定义的时候就决定了，而与词法作用域相对的是动态作用域，函数的作用域是在函数调用时才决定的</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>    foo()<br>&#125;<br>bar() <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">/* 分析上面代码执行过程：因为js采用的是词法作用域， </span><br><span class="hljs-comment">执行foo函数，先从函数内部查找是否有局部变量a，如果</span><br><span class="hljs-comment">没有，就根据书写的位置，查找上一层的代码，也就是a等</span><br><span class="hljs-comment">于1，所以会打印1， 如果是动态作用域，会从调用函数的</span><br><span class="hljs-comment">作用域查找变量，也就是bar的内部，会打印2 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型到原型链</title>
    <link href="/2021/01/17/%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2021/01/17/%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="原型到原型链"><a href="#原型到原型链" class="headerlink" title="原型到原型链"></a>原型到原型链</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每个函数都有一个prototype属性，这个属性指向了一个对象，这个对象正是用该构造函数创建的实例的原型</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// prototype 是函数才有的属性</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;<br>Person.prototype.alias = <span class="hljs-string">&#x27;monster&#x27;</span><br><span class="hljs-keyword">const</span> michael = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-keyword">const</span> andrew = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-built_in">console</span>.log(michael.alias) <span class="hljs-comment">// monster</span><br><span class="hljs-built_in">console</span>.log(andrew.alias) <span class="hljs-comment">// monster</span><br></code></pre></td></tr></table></figure></code></pre><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p>每一个JavaScritp对象(null除外)都有一个__proto__属性，这个属性会指向该对象的原型</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;<br><span class="hljs-keyword">const</span> michael = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-built_in">console</span>.log(michael.__proto__ === Person.prototype) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>原型： 每一个JavaScript对象(null除外)在创建的时候会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性</code></pre><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>每个原型都有一个 constructor 属性指向关联的构造函数</p><pre><code><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment"></span></span><br><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><br><span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">(Person === Person.prototype.<span class="hljs-keyword">constructor</span>)</span>;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></code></pre><h3 id="如下图-对象之间形成了一条原型链"><a href="#如下图-对象之间形成了一条原型链" class="headerlink" title="如下图 对象之间形成了一条原型链"></a>如下图 对象之间形成了一条原型链</h3><p><img src="/images/prototypeChain.png"></p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
